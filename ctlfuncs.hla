// Compile-time functions module.
//
// This code contains all the code that parses
// HLA compile-time functions.
//
// This code is suffering a bit from "cut&Paste"-itis
// and could easily be shrunk to one-half it's current
// size with appropriate redesign.

unit ctlFuncs;

#include( "stdlib.hhf" )
#include( "hlacompiler.hhf" )						

?@nodisplay := true;
?@noalignstack := true;



#macro toUpper( toConvert ):notAlpha;
	cmp( toConvert, 'a' );
	jb notAlpha;
	and( $5f, toConvert );
  notAlpha:
#endmacro




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// doAtText Function:
//
// Processes the @TEXT "function" for the lexer.

//proc( "doAtText" )
procedure doAtText;
var
	attr:	attr_t;

begin doAtText;

	defaultAttr( attr );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			mustMatchRParen();
			// Feed the string back into the
			// lexer to use as text:
			
			pushBackStr( attr.string_vt );
			clc();
			exit noerror;

		end error;
		
		// If some sort of error, eat everything up
		// to a closing parenthesis:
		
		getRightParen();
		freeAttr( attrEBX );
		defaultAttr( attr );
		stc();

	end noerror;

end doAtText;


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Coercion Functions:
//
//
// integerFunc- handles the integer/numeric type coercion functions


//proc( "integerFunc" )
procedure integerFunc( var attr:attr_t );
var
	cwSave	:word;
	newCW	:word;
	sign	:boolean;
	error	:boolean;

begin integerFunc;

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	mov( false, error );

	// Convert the constant expression's value to an integer:

	mov( attr, ebx );
	canAccess( [ebx] );
	movzx( attrEBX.pType, eax );
	switch( eax )

		// Just pass these types on through without conversion
		// They're already integers. So let the caller handle
		// range checking and stuff like that.

		case
		(
			Byte_pt,			//0
			Word_pt,			//1
			DWord_pt,			//2
			QWord_pt,			//3
			TByte_pt,			//4
			LWord_pt,			//5

			Uns8_pt,			//6
			Uns16_pt,			//7
			Uns32_pt,			//8
			Uns64_pt,			//9
			Uns128_pt,			//10

			Int8_pt,			//11
			Int16_pt,			//12
			Int32_pt,			//13
			Int64_pt,			//14
			Int128_pt,			//15

			Boolean_pt,			//20 
			Enum_pt,			//21

			Char_pt, 			//22
			XChar_pt,			//23
			Unicode_pt			//24
		)

			/* do nothing if one of the above cases */


		// For real values, we must convert the values
		// to an integer:

		case( Real32_pt )			//16

			// Save FPU mode and set rounding mode to "truncate"

			fstcw( cwSave );
			fstcw( newCW );
			or( $0c00, newCW );
			fldcw( newCW );

			fld( attrEBX.real32_vt );
			zeroAttr( [ebx] );
			fistp( attrEBX.int32_vt );

			fldcw( cwSave );
			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );


		case( Real64_pt )			//17

			// Save FPU mode and set rounding mode to "truncate"

			fstcw( cwSave );
			fstcw( newCW );
			or( $0c00, newCW );
			fldcw( newCW );

			fld( attrEBX.real64_vt );
			zeroAttr( [ebx] );
			fistp( attrEBX.int64_vt );

			fldcw( cwSave );
			mov( Int64_pt, attrEBX.pType );
			mov( &int64_ste, attrEBX.symType );

		case( Real80_pt )			//18


			// Okay, we've got an 80-bit real, convert it to an
			// integer, if possible. Note, at some point we
			// really ought to do a manual conversion to 128
			// bits, but this will suffice for now.

			// Save FPU mode and set rounding mode to "truncate"

			fstcw( cwSave );
			fstcw( newCW );
			or( $0c00, newCW );
			fldcw( newCW );

			fld( attrEBX.real80_vt );
			zeroAttr( [ebx] );
			fistp( attrEBX.int64_vt );

			fldcw( cwSave );
			mov( Int64_pt, attrEBX.pType );
			mov( &int64_ste, attrEBX.symType );


		case
		(
			String_pt,
			Utf8_pt,
			UString_pt
		)

				// Begin by converting unicode strings to ANSI,
				// if necessary:
				
				if( al = UString_pt ) then

					unicodeToAnsi( attrEBX.string_vt );
					if( @c ) then

						HLAerror
						(
							"Unicode string contains invalid digits"
							nl
						);
						freeAttr( attrEBX );
						raise( ex.hlaerr );
						
					endif;

				elseif( al = Utf8_pt ) then

					utf8ToAnsi( attrEBX.string_vt );
					if( @c ) then

						HLAerror
						(
							"UTF-8 string contains invalid digits"
							nl
						);
						freeAttr( attrEBX );
						raise( ex.hlaerr );
						
					endif;

				endif;
				mov( attrEBX.string_vt, ecx );
				canAccess( [ecx] );
				push( ecx );	// Save for later deallocation
				
				// If the string begins with a "$", assume
				// it's a hexadecimal constant:
				
				mov((type char [ecx]), al );
				if( al = '$' ) then

					push( esi );
					inc( ecx );
					getHexConst( ecx, [ebx] );
					pop( esi );
					if( @c ) then

						HLAerror
						( 
							"String does not contain valid hex digits" 
							nl 
						);
						// Free up any storage used by the expression:

						freeAttr( [ebx] );
						raise( ex.hlaerr );
					endif;						

				// If the string begins with a '%' then assume
				// it's a binary constant:
				
				elseif( al = '%' ) then

					push( esi );
					inc( ecx );
					getBinConst( ecx, [ebx] );
					pop( esi );
					if( @c ) then

						HLAerror
						( 
							"String does not contain valid binary digits" 
							nl 
						);
						// Free up any storage used by the expression:

						freeAttr( [ebx] );
						raise( ex.hlaerr );
					endif;						

				// If no special prefix, assume we've got a decimal constant:
				
				else

					// Check for a leading sign for signed integers:
					
					mov( false, sign );
					if( al = '-' ) then

						mov( true, sign );
						inc( ecx );

					endif;
					push( esi );
					getDecConst( ecx, [ebx] );
					pop( esi );
					if( @c ) then

						HLAerror
						( 
							"String does not contain valid decimal digits" 
							nl 
						);
						// Free up any storage used by the expression:

						freeAttr( [ebx] );
						raise( ex.hlaerr );
					elseif( sign ) then

						// If there was a leading sign, negate the
						// result.
						
						mov( 0, eax );
						sub( attrEBX.dword_vt[0], eax );
						mov( eax, attrEBX.dword_vt[0] );

						mov( 0, eax );
						sbb( attrEBX.dword_vt[4], eax );
						mov( eax, attrEBX.dword_vt[4] );

						mov( 0, eax );
						sbb( attrEBX.dword_vt[8], eax );
						mov( eax, attrEBX.dword_vt[8] );

						mov( 0, eax );
						sbb( attrEBX.dword_vt[12], eax );
						mov( eax, attrEBX.dword_vt[12] );

						mov( attrEBX.pType, al );
						add( byte(Int8_pt)-byte(Uns8_pt), al );
						mov( al, attrEBX.pType );

					endif;						

				endif;

				// Deallocate the string:

				call( str.free );	// Parameter was pushed earlier

		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to numeric form" 
				nl 
			);

			// Free up any storage used by the expression:

			freeAttr( [ebx] );
			raise( ex.hlaerr );

	endswitch;


	shr( 1, error );	// Put error status in carry flag, 1=error.
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );

end integerFunc;


// genericByteFunc- Used to convert data types to something
// that will fit into eight bits:

//proc( "genericByteFunc" )
procedure genericByteFunc( var attr:attr_t in ebx );
begin genericByteFunc;
	
	push( eax );
	push( edx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( [ebx] );
	if( @nc ) then

		// It was a good conversion, now verify
		// that the result fits in a byte.
		//
		// Algorithm: if the upper 120 bits of
		// the value are all zeros, then the
		// result is acceptable. Otherwise, if
		// the upper 128 bits are equal to the
		// value in bit #7, the result is acceptable.

		movzx( attrEBX.uns8_vt, eax );
		cdq();
		if
		(
				eax <> attrEBX.uns32_vt
			||	edx <> attrEBX.uns32_vt[4]
			||	edx <> attrEBX.uns32_vt[8]
			||	edx <> attrEBX.uns32_vt[12]
		) then
			movsx( attrEBX.int8_vt, eax );
			cdq();
			if
			(
					eax <> attrEBX.uns32_vt
				||	edx <> attrEBX.uns32_vt[4]
				||	edx <> attrEBX.uns32_vt[8]
				||	edx <> attrEBX.uns32_vt[12]
			) then

				HLAerror( "Result too large for eight bits" nl );
				raise( ex.hlaerr );

			endif;

		endif;
		mov( Byte_pt, attrEBX.pType );
		mov( &byte_ste, attrEBX.symType );
		clc();
	
	endif;
	pop( edx );
	pop( eax );

end genericByteFunc;


// genericWordFunc - used to convert data objects into
// a numeric value that will fit into 16 bits:

//proc( "genericWordFunc" )
procedure genericWordFunc( var attr:attr_t in ebx );
begin genericWordFunc;
	
	push( eax );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( [ebx] );
	if( @nc ) then

		// It was a good conversion, now verify
		// that the result fits in a word
		//
		// Algorithm: if the upper 112 bits of
		// the value are all zeros, then the
		// result is acceptable. Otherwise, if
		// the upper 112 bits are equal to the
		// value in bit #15, the result is acceptable.

		movzx( attrEBX.uns16_vt, eax );
		cdq();
		if
		(
				eax <> attrEBX.uns32_vt
			||	edx <> attrEBX.uns32_vt[4]
			||	edx <> attrEBX.uns32_vt[8]
			||	edx <> attrEBX.uns32_vt[12]
		) then
			movsx( attrEBX.int16_vt, eax );
			cdq();
			if
			(
					eax <> attrEBX.uns32_vt
				||	edx <> attrEBX.uns32_vt[4]
				||	edx <> attrEBX.uns32_vt[8]
				||	edx <> attrEBX.uns32_vt[12]
			) then

				HLAerror( "Result too large for 16 bits" nl );
				raise( ex.hlaerr );

			endif;

		endif;
		mov( Word_pt, attrEBX.pType );
		mov( &word_ste, attrEBX.symType );
		clc();
	
	endif;
	pop( eax );

end genericWordFunc;


// genericDWordFunc - used to convert data objects into
// numeric form that will fit into 32 bits:

//proc( "genericDWordFunc" )
procedure genericDWordFunc( var attr:attr_t in ebx );
begin genericDWordFunc;
	
	push( eax );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( [ebx] );
	if( @nc ) then

		// It was a good conversion, now verify
		// that the result fits in a dword
		//
		// Algorithm: if the upper 96 bits of
		// the value are all zeros, then the
		// result is acceptable. Otherwise, if
		// the upper 96 bits are equal to the
		// value in bit #31, the result is acceptable.

		mov( attrEBX.uns32_vt, eax );
		xor( edx, edx );
		if
		(
				eax <> attrEBX.uns32_vt
			||	edx <> attrEBX.uns32_vt[4]
			||	edx <> attrEBX.uns32_vt[8]
			||	edx <> attrEBX.uns32_vt[12]
		) then
			cdq();
			if
			(
					eax <> attrEBX.uns32_vt
				||	edx <> attrEBX.uns32_vt[4]
				||	edx <> attrEBX.uns32_vt[8]
				||	edx <> attrEBX.uns32_vt[12]
			) then

				HLAerror( "Result too large for 32 bits" nl );
				raise( ex.hlaerr );

			endif;

		endif;

		mov( DWord_pt, attrEBX.pType );
		mov( &dword_ste, attrEBX.symType );
		clc();
	
	endif;
	pop( eax );

end genericDWordFunc;


// genericQWordFunc - used to convert data objects into
// numeric form that will fit into 64 bits:

//proc( "genericQWordFunc" )
procedure genericQWordFunc( var attr:attr_t in ebx );
begin genericQWordFunc;
	
	push( eax );
	push( edx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( [ebx] );
	if( @nc ) then

		// It was a good conversion, now verify
		// that the result fits in a qword
		//
		// Algorithm: if the upper 64 bits of
		// the value are all zeros, then the
		// result is acceptable. Otherwise, if
		// the upper 64 bits are equal to the
		// value in bit #63, the result is acceptable.

		mov( attrEBX.uns32_vt[4], eax );
		xor( edx, edx );
		if
		(
				eax <> attrEBX.uns32_vt[4]
			||	edx <> attrEBX.uns32_vt[8]
			||	edx <> attrEBX.uns32_vt[12]
		) then
			cdq();
			if
			(
					eax <> attrEBX.uns32_vt[4]
				||	edx <> attrEBX.uns32_vt[8]
				||	edx <> attrEBX.uns32_vt[12]
			) then

				HLAerror( "Result too large for 64 bits" nl );
				raise( ex.hlaerr );

			endif;

		endif;

		mov( QWord_pt, attrEBX.pType );
		mov( &qword_ste, attrEBX.symType );
		clc();
	
	endif;
	pop( edx );
	pop( eax );

end genericQWordFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "byte( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "byteFunc" )
procedure byteFunc( var attr:attr_t );
begin byteFunc;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericByteFunc( attrEBX );
	pop( ebx );

end byteFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "word( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "wordFunc" )
procedure wordFunc( var attr:attr_t );	
begin wordFunc;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericWordFunc( attrEBX );
	pop( ebx );

end wordFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "dword( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "dwordFunc" )
procedure dwordFunc( var attr:attr_t );	
begin dwordFunc;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericDWordFunc( attrEBX );
	pop( ebx );

end dwordFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "qword( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "qwordFunc" )
procedure qwordFunc( var attr:attr_t );	
begin qwordFunc;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericQWordFunc( attrEBX );
	pop( ebx );

end qwordFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "tbyte( expr )" function here.
// Returns carry clear if successful, carry set if error.

//proc( "tbyteFunc" )
procedure tbyteFunc( var attr:attr_t );	
begin tbyteFunc;
	
	push( eax );
	push( ebx );
	push( edx );
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( attrEBX );
	if( @nc ) then

		// It was a good conversion, now verify
		// that the result fits in a tbyte
		//
		// Algorithm: if the upper 48 bits of
		// the value are all zeros, then the
		// result is acceptable. Otherwise, if
		// the upper 48 bits are equal to the
		// value in bit #79, the result is acceptable.

		movzx( attrEBX.uns16_vt[8], eax );
		cdq();
		if
		(
				eax <> attrEBX.uns32_vt[8]
			||	edx <> attrEBX.uns32_vt[12]
		) then

			movsx( attrEBX.int16_vt[8], eax );
			cdq();
			if
			(
					eax <> attrEBX.int32_vt[8]
				&&	edx <> attrEBX.int32_vt[12]
			) then
				HLAerror( "Result too large for 80 bits" nl );
				raise( ex.hlaerr );

			endif;

		endif;

		movsx( attrEBX.word_vt[8], eax );
		cdq();
		if
		( 
				eax <> attrEBX.dword_vt[8]
			||	edx <> attrEBX.dword_vt[12] 
		) then

			HLAerror( "Result too large for 80 bits" nl );
			raise( ex.hlaerr );
		endif;
		mov( TByte_pt, attrEBX.pType );
		mov( &tbyte_ste, attrEBX.symType );
		clc();
	
	endif;
	pop( edx );
	pop( ebx );
	pop( eax );

end tbyteFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "lword( expr )" function here.
// Returns carry clear if successful, carry set if error.

//proc( "lwordFunc" )
procedure lwordFunc( var attr:attr_t );	
begin lwordFunc;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	integerFunc( attrEBX );
	mov( LWord_pt, attrEBX.pType );
	mov( &lword_ste, attrEBX.symType );
	pop( ebx );

end lwordFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "uns8( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "uns8Func" )
procedure uns8Func( var attr:attr_t );	
begin uns8Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericByteFunc( attrEBX );
	if( @nc ) then

		mov( Uns8_pt, attrEBX.pType );
		mov( &uns8_ste, attrEBX.symType );

	endif;
	pop( ebx );

end uns8Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "uns16( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "uns16Func" )
procedure uns16Func( var attr:attr_t );	
begin uns16Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericWordFunc( attrEBX );
	if( @nc ) then

		mov( Uns16_pt, attrEBX.pType );
		mov( &uns16_ste, attrEBX.symType );

	endif;
	pop( ebx );

end uns16Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "uns32( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "uns32Func" )
procedure uns32Func( var attr:attr_t );	
begin uns32Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericDWordFunc( attrEBX );
	if( @nc ) then

		mov( Uns32_pt, attrEBX.pType );
		mov( &uns32_ste, attrEBX.symType );

	endif;
	pop( ebx );

end uns32Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "uns64( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "uns64Func" )
procedure uns64Func( var attr:attr_t );	
begin uns64Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericQWordFunc( attrEBX );
	if( @nc ) then

		mov( Uns64_pt, attrEBX.pType );
		mov( &uns64_ste, attrEBX.symType );

	endif;
	pop( ebx );

end uns64Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "uns128( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "uns128Func" )
procedure uns128Func( var attr:attr_t );
begin uns128Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	integerFunc( attrEBX );
	mov( Uns128_pt, attrEBX.pType );
	mov( &uns128_ste, attrEBX.symType );
	pop( ebx );

end uns128Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "int8( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "int8Func" )
procedure int8Func( var attr:attr_t );	
begin int8Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericByteFunc( attrEBX );
	if( @nc ) then

		mov( Int8_pt, attrEBX.pType );
		mov( &int8_ste, attrEBX.symType );

	endif;
	pop( ebx );

end int8Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "int16( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "int16Func" )
procedure int16Func( var attr:attr_t );	
begin int16Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericWordFunc( attrEBX );
	if( @nc ) then

		mov( Int16_pt, attrEBX.pType );
		mov( &int16_ste, attrEBX.symType );

	endif;
	pop( ebx );

end int16Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "int32( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "int32Func" )
procedure int32Func( var attr:attr_t );	
begin int32Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericDWordFunc( attrEBX );
	if( @nc ) then

		mov( Int32_pt, attrEBX.pType );
		mov( &int32_ste, attrEBX.symType );

	endif;
	pop( ebx );

end int32Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "int64( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "int64Func" )
procedure int64Func( var attr:attr_t );	
begin int64Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericQWordFunc( attrEBX );
	if( @nc ) then

		mov( Int64_pt, attrEBX.pType );
		mov( &int64_ste, attrEBX.symType );

	endif;
	pop( ebx );

end int64Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "int128( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "int128Func" )
procedure int128Func( var attr:attr_t );	
begin int128Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	integerFunc( attrEBX );
	mov( Int128_pt, attrEBX.pType );
	mov( &int128_ste, attrEBX.symType );
	pop( ebx );

end int128Func;




///////////////////////////////////////////////////////////////////////////////
//
// Generic REAL conversion functions:

//proc( "makeReal80" )
procedure makeReal80( var attr: attr_t );
var
	saveESI	:dword;
	saveEDI	:dword;
	fixReal:union
				w:word[5];
				r:real80;
			endunion;

	error:boolean;

readonly
	two :int32 := 2;

begin makeReal80;

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	mov( false, error );

	mov( attr, ebx );
	canAccess( [ebx] );
	movzx( attrEBX.pType, eax );
	switch( eax )

		// Convert integer values to real and leave on the FPU stack:

		case
		(
			Byte_pt,			//0
			Uns8_pt,			//6
			Boolean_pt,			//20 
			Enum_pt,			//21
			Char_pt, 			//22
			XChar_pt			//23
		)
			mov( 0, attrEBX.byte_vt[1] );
			fild( attrEBX.int16_vt );

		case
		(
			Word_pt,			//1
			Uns16_pt,			//7
			Unicode_pt			//24
		)
			mov( 0, attrEBX.word_vt[2] );

			fild( attrEBX.int32_vt );

		case
		(		
			DWord_pt,			//2
			Uns32_pt			//8
		)
			mov( 0, attrEBX.dword_vt[4] );
			fild( attrEBX.int64_vt );

		case
		(
			QWord_pt,			//3
			Int64_pt			//14
		)
			
			fild( attrEBX.int64_vt );

		case( Int8_pt )	 //11

			movsx( attrEBX.int8_vt, eax );
			mov( eax, attrEBX.int32_vt );
			fild( attrEBX.int32_vt );

		case( Int16_pt )  //12

			movsx( attrEBX.int16_vt, eax );
			mov( eax, attrEBX.int32_vt );
			fild( attrEBX.int32_vt );

		case( Int32_pt ) //13

			fild( attrEBX.int32_vt );

		// Special case for Uns64 that checks for overflow:

		case( Uns64_pt )

			mov( attrEBX.dword_vt[4], eax );
			test( $8000_0000, eax );
			if( @nz ) then

				shr( 1, eax );
				mov( eax, attrEBX.dword_vt[4] );
				rcr( 1, attrEBX.dword_vt[0] );
				fild( attrEBX.int64_vt );
				fild( two );
				fdiv();

			else

				fild( attrEBX.int64_vt );

			endif;

		

		// For the very large integer values, we have to play some
		// games:

		case
		(
			Uns128_pt,			//10
			LWord_pt,			//5  -- Assume zero extended to 128 bits.
			TByte_pt			//4	 -- Treat as unsigned for our purposes.
		)

			xor( edx, edx );
			forever

				mov( attrEBX.dword_vt[12], eax );
				or( attrEBX.dword_vt[8], eax );
				mov( attrEBX.dword_vt[4], ecx );
				and( $8000_0000, ecx );
				or( ecx, eax );
				breakif( @z );
				shr( 1,	attrEBX.dword_vt[12] );
				rcr( 1,	attrEBX.dword_vt[8] );
				rcr( 1,	attrEBX.dword_vt[4] );
				rcr( 1,	attrEBX.dword_vt[0] );
				inc( edx );

			endfor;

			// Bump the exponent up by the amount we
			// had to shift down:

			fild( attrEBX.int64_vt );
			fstp( fixReal.r );
			add( dx, fixReal.w[8] );
			fld( fixReal.r );

			
		case( Int128_pt )

			if( attrEBX.byte_vt[15] >= $80 ) then

				xor( ecx, ecx );
				movsx( attrEBX.byte_vt[15], eax );
				cdq();
				while
				( 
						edx <> attrEBX.dword_vt[8]
					&&	edx <> attrEBX.dword_vt[12]
				) do

					// Shift the whole mess down by one position:

					sar( 1,	attrEBX.dword_vt[12] );
					rcr( 1,	attrEBX.dword_vt[8] );
					rcr( 1,	attrEBX.dword_vt[4] );
					rcr( 1,	attrEBX.dword_vt[0] );

					// Increment the (binary) exponent to account
					// for the fact that we just divided the value by two:

					inc( ecx );

				endwhile;

				// Bump the exponent up by the amount we
				// had to shift down:

				fild( attrEBX.int64_vt );
				fstp( fixReal.r );
				add( cx, fixReal.w[8] );
				fld( fixReal.r );

			else // It needs to be a non-negative value:

				// We need to reduce this to a 63-bit number
				// if we want to stand a chance of converting
				// it to a real80 value:

				xor( edx, edx );	// Maintain exponent adjustment here.
				forever

					// If any of the upper 65 bits are non-zero,
					// then shift the bits down one position (that is,
					// divide by two) and bump up our exponent adjustment
					// by one.

					mov( attrEBX.dword_vt[12], eax );
					or( attrEBX.dword_vt[8], eax );
					mov( attrEBX.dword_vt[7], ecx );
					and( $8000_0000, ecx );
					or( ecx, eax );
					breakif( @z );
					shr( 1,	attrEBX.dword_vt[12] );
					rcr( 1,	attrEBX.dword_vt[8] );
					rcr( 1,	attrEBX.dword_vt[4] );
					rcr( 1,	attrEBX.dword_vt[0] );
					inc( edx );

				endfor;

				// Bump the exponent up by the amount we
				// had to shift down:

				fild( attrEBX.int64_vt );
				fstp( fixReal.r );
				add( dx, fixReal.w[8] );
				fld( fixReal.r );

			endif;


		// For real values, just leave them on the stack:

		case( Real32_pt )			//16

			fld( attrEBX.real32_vt );

		case( Real64_pt )			//17

			fld( attrEBX.real64_vt );

		case( Real80_pt )			//18

			fld( attrEBX.real80_vt );

		case
		(
			String_pt,
			Utf8_pt,
			UString_pt
		)

			if( al = UString_pt ) then

				unicodeToAnsi( attrEBX.string_vt );
				if( @c ) then

					HLAerror
					( 
						"Unicode string contains illegal characters (cannot "
						"convert to real)"
						nl
					);
					raise( ex.hlaerr );

				endif;

			elseif( al = Utf8_pt ) then

				utf8ToAnsi( attrEBX.string_vt );
				if( @c ) then

					HLAerror
					( 
						"UTF-8 string contains illegal characters (cannot "
						"convert to real)"
						nl
					);
					raise( ex.hlaerr );

				endif;

			endif;
			mov( attrEBX.string_vt, ecx );
			try
			
				mov( esi, saveESI );
				mov( edi, saveEDI );
				conv.strToFlt( ecx, 0 );					
				mov( false, al );				// If no exception, it's valid.
				
			  exception( ex.MemoryAllocationFailure )

				raise( ex.MemoryAllocationFailure );
			
			  anyexception
			  
			  	// An exception can occur if there is massive overflow
				// or other problems with the number.
				
				mov( saveESI, esi );
				mov( saveEDI, edi );
				HLAerror
				( 
					"Error converting string to floating point value" nl 
				);
				freeAttr( attrEBX );
				raise( ex.hlaerr );
			endtry;

			// Deallocate the string:

			mov( attr, ebx );
			strfree( attrEBX.string_vt );

		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to real" 
				nl 
			);
			
			// Free up any storage used by the expression:

			freeAttr( [ebx] );
			raise( ex.hlaerr );
			
	endswitch;

	shr( 1, error );	// Put error status in carry flag, 1=error.
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );

end makeReal80;




///////////////////////////////////////////////////////////////////////////////
//
// Handle "real32( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "real32Func" )
procedure real32Func( var attr:attr_t );	
begin real32Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	finit();
	fclex();
	makeReal80( attrEBX );
	fstp( attrEBX.real32_vt );
	mov( Real32_pt, attrEBX.pType );
	mov( &real32_ste, attrEBX.symType );
	pop( ebx );

end real32Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "real64( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "real64Func" )
procedure real64Func( var attr:attr_t );	
begin real64Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	finit();
	fclex();
	makeReal80( attrEBX );
	fstp( attrEBX.real64_vt );
	mov( Real64_pt, attrEBX.pType );
	mov( &real64_ste, attrEBX.symType );
	pop( ebx );

end real64Func;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "real80( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "real80Func" )
procedure real80Func( var attr:attr_t );	
begin real80Func;
	
	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Do a generic conversion to integer:

	finit();
	fclex();
	makeReal80( attrEBX );
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	pop( ebx );

end real80Func;




///////////////////////////////////////////////////////////////////////////////
//
// Generic character conversion function

//proc( "genericCharFunc" )
procedure genericCharFunc( var attr:attr_t in ebx );
begin genericCharFunc;

	pushABCD;

	// Convert the constant expression's value to a character:

	mov( attr, ebx );
	canAccess( [ebx] );
	movzx( attrEBX.pType, eax );
	switch( eax )


		// Just pass these types on through without conversion
		// They're already integers. So let the caller handle
		// range checking and stuff like that.

		case
		(
			Byte_pt,			//0
			Word_pt,			//1
			DWord_pt,			//2
			QWord_pt,			//3
			TByte_pt,			//4
			LWord_pt,			//5

			Uns8_pt,			//6
			Uns16_pt,			//7
			Uns32_pt,			//8
			Uns64_pt,			//9
			Uns128_pt,			//10

			Int8_pt,			//11
			Int16_pt,			//12
			Int32_pt,			//13
			Int64_pt,			//14
			Int128_pt,			//15

			Boolean_pt,			//20 
			Enum_pt,			//21

			Char_pt, 			//22
			XChar_pt,			//23
			Unicode_pt			//24
		)



		case( String_pt )

			// Replace the pointer to the string with
			// the first character of the string, zero
			// extended to 32-bits.

			mov( attrEBX.string_vt, ecx );
			canAccess( [ecx] );
			movzx( (type char [ecx]), eax );
			strfree( ecx );
			mov( eax, attrEBX.dword_vt );


		case( Utf8_pt )

			// Replace the pointer to the string with
			// the first character of the string, zero
			// extended to 32-bits.

			utf8ToUnicode( attrEBX.string_vt );
			if( @c ) then

				strfree( eax );
				HLAerror( "Error converting UTF-8 string to a character" nl );
				raise( ex.hlaerr );

			endif;
			strfree( attrEBX.string_vt );
			movzx( (type word [eax]), ecx );
			strfree( eax );
			mov( ecx, attrEBX.dword_vt );


		case( UString_pt )


			// Replace the pointer to the string with
			// the first character of the string, zero
			// extended to 32-bits.

			mov( attrEBX.string_vt, ecx );
			canAccess( [ecx] );
			movzx( (type word [ecx]), eax );
			strfree( ecx );
			mov( eax, attrEBX.dword_vt );


		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to character form" 
				nl 
			);

			// Free up any storage used by the expression:

			freeAttr( [ebx] );
			raise( ex.hlaerr );

	endswitch;
	clc();
	popABCD;

end genericCharFunc;

///////////////////////////////////////////////////////////////////////////////
//
// Handle "unicode( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "unicodeFunc" )
procedure unicodeFunc( var attr:attr_t );	
begin unicodeFunc;

	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericCharFunc( [ebx] );
	if( @nc ) then

		mov( attrEBX.dword_vt, eax );
		mov( 0, ax );
		or( attrEBX.dword_vt[4], eax );
		or( attrEBX.dword_vt[8], eax );
		or( attrEBX.dword_vt[12], eax );
		if( @nz ) then

			HLAerror( "Value out of range for unicode conversion" nl );
			freeAttr( attrEBX );
			raise( ex.hlaerr );

		endif;

	endif;
	mov( Unicode_pt, attrEBX.pType );
	mov( &unicode_ste, attrEBX.symType );
	pop( ebx );
	clc();
	exit unicodeFunc;


end unicodeFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "char( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "charFunc" )
procedure charFunc( var attr:attr_t );	
begin charFunc;

	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericCharFunc( [ebx] );
	if( @nc ) then

		mov( attrEBX.dword_vt, eax );
		and( $80, al );
		or( attrEBX.dword_vt[4], eax );
		or( attrEBX.dword_vt[8], eax );
		or( attrEBX.dword_vt[12], eax );
		if( @nz ) then

			HLAerror( "Value out of range for char conversion" nl );
			freeAttr( attrEBX );
			raise( ex.hlaerr );

		endif;

	endif;
	mov( Char_pt, attrEBX.pType );
	mov( &char_ste, attrEBX.symType );
	pop( ebx );
	exit charFunc;

end charFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "xchar( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "xcharFunc" )
procedure xcharFunc( var attr:attr_t );	
begin xcharFunc;

	push( ebx );
	mov( attr, ebx );
	canAccess( [ebx] );
	genericCharFunc( [ebx] );
	if( @nc ) then

		mov( attrEBX.dword_vt, eax );
		mov( 0, al );
		or( attrEBX.dword_vt[4], eax );
		or( attrEBX.dword_vt[8], eax );
		or( attrEBX.dword_vt[12], eax );
		if( @nz ) then

			HLAerror( "Value out of range for xchar conversion" nl );
			freeAttr( attrEBX );
			raise( ex.hlaerr );

		endif;

	endif;
	mov( XChar_pt, attrEBX.pType );
	mov( &xchar_ste, attrEBX.symType );
	pop( ebx );
	exit xcharFunc;

end xcharFunc;


///////////////////////////////////////////////////////////////////////////////
//
// genericStrFunc-
//
//	Converts a given data type to a string and returns a pointer to the
// resultant string in EAX (if successful, no string pointer returned
// if there was an error).
//
//	Returns carry set if error, clear if conversion was legal.

//proc( "genericStrFunc" )
procedure genericStrFunc( var attr:attr_t in ecx );
var
	resultStr	:string;
		
begin genericStrFunc;

	// Allocate a temporary buffer to hold the result
	// (also initializes the string to the empty string).

	tstralloc( 1024 );
	mov( eax, resultStr );

	// Convert the data to a string based on the
	// object's type:

	mov( attr, ecx );
	canAccess( [ecx] );
	movzx( attrECX.pType, eax );
	switch( eax )

		case( Byte_pt )
			
			conv.h8ToStr( attrECX.byte_vt, 2, '0', resultStr );

		case( Word_pt )

			conv.h16ToStr( attrECX.word_vt, 4, '0', resultStr );

		case( DWord_pt )

			conv.h32ToStr( attrECX.dword_vt, 8, '0', resultStr );

		case( QWord_pt )

			conv.h64ToStr( attrECX.qword_vt, 16, '0', resultStr );

		case( TByte_pt )

			conv.h80ToStr( attrECX.tbyte_vt, 20, '0', resultStr );

		case( LWord_pt )
			
			conv.h128ToStr( attrECX.lword_vt, 32, '0', resultStr );

		case
		(
			Uns8_pt,
			Uns16_pt,
			Uns32_pt,
			Uns64_pt,
			Uns128_pt
		)

			conv.u128ToStr( attrECX.uns128_vt, 1, ' ', resultStr );

		case
		(
			Int8_pt,	
			Int16_pt,	
			Int32_pt,	
			Int64_pt,	
			Int128_pt
		)
		
			conv.i128ToStr( attrECX.int128_vt, 1, ' ', resultStr );
			
		case( Real32_pt )
		
			finit();
			fclex();
			str.put( resultStr, attrECX.real32_vt );
			
		case( Real64_pt )
		
			finit();
			fclex();
			str.put( resultStr, attrECX.real64_vt );
			
		case( Real80_pt )
		
			finit();
			fclex();
			str.put( resultStr, attrECX.real80_vt );

		case( Boolean_pt )

			str.put( resultStr, attrECX.boolean_vt );

		case
		(
			Char_pt,
			XChar_pt,
			Unicode_pt
		)

			str.put( resultStr, attrECX.char_vt );

		case( String_pt )

			mov( attrECX.string_vt, eax );
			mov( eax, resultStr );

		case( Utf8_pt )

			// Note that utf8ToANSI returns the carry
			// set if there was a conversion error.

			utf8ToAnsi( attrECX.string_vt );
			if( @c ) then

				HLAerror
				(
					"Error converting UTF-8 string to ANSI"
					nl
				);
				freeAttr( attrECX );
				raise( ex.hlaerr );

			endif;
			mov( attrECX.string_vt, eax );
			mov( eax, resultStr );

		case( UString_pt )

			// Note that unicodeToANSI returns the carry
			// set if there was a conversion error.

			unicodeToAnsi( attrECX.string_vt );
			if( @c ) then

				HLAerror
				(
					"Error converting Unicode string to ANSI"
					nl
				);
				freeAttr( attrECX );
				raise( ex.hlaerr );

			endif;
			mov( attrECX.string_vt, eax );
			mov( eax, resultStr );
						

		case( Cset_pt )

			str.put( resultStr, attrECX.cset_vt );

		case( XCset_pt )

			// First, emit all characters associated with
			// the second half of the character set:

			tstralloc( 128 );
			str.catcset( eax, attrECX.cset_vt[16] );

			// Must set the H.O. bit of each of the
			// characters in this string:

			push( eax );
			while( (type byte [eax]) <> #0 ) do

				or( $80, (type char [eax]) );
				inc( eax );

			endwhile;
			pop( eax );
			str.catcset( eax, attrECX.cset_vt );

		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to character form" 
				nl 
			);
			freeAttr( [ecx] );
			//freeAttr( attrEBX ); // not pass by value?
			mov( attr, ecx);
			freeAttr( [ecx] );
			raise( ex.hlaerr );

	endswitch;
	
	// Return a pointer to a new copy of the string on the heap
	// in EAX:

	str.a_cpy( resultStr );

end genericStrFunc;

///////////////////////////////////////////////////////////////////////////////
//
// Handle "string( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "stringFunc" )
procedure stringFunc( var attr:attr_t );
begin stringFunc;

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	mov( attr, ecx );
	canAccess( [ecx] );
	genericStrFunc( [ecx] );
	mov( attr, ecx );
	mov( eax, attrECX.string_vt );
	mov( String_pt, attrECX.pType );
	mov( &string_ste, attrECX.symType );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );	

end stringFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "wstring( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "ustringFunc" )
procedure ustringFunc( var attr:attr_t );	
begin ustringFunc;
		
	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	mov( attr, ecx );
	canAccess( [ecx] );
	genericStrFunc( [ecx] );  // Returns string ptr in EAX.

	// Convert the string to unicode and then
	// free the original string (unless the
	// original string was unicode, in which
	// case we do nothing):

	canAccess( [eax] );
	push( eax );		// Save for use by strfree.
	ansiToUnicode( eax );

	mov( eax, attrECX.string_vt );
	call( strfree ); // Parameter was pushed earlier.
			 
	mov( UString_pt, attrECX.pType );
	mov( &ustring_ste, attrECX.symType );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );	

end ustringFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "utf8( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "utf8Func" )
procedure utf8Func( var attr:attr_t );	
begin utf8Func;
		
	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	mov( attr, ecx );
	canAccess( [ecx] );
	genericStrFunc( [ecx] );  // Returns string ptr in EAX.


	canAccess( [eax] );
	mov( eax, attrECX.string_vt );
			 
	mov( Utf8_pt, attrECX.pType );
	mov( &utf8_ste, attrECX.symType );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );	

end utf8Func;


///////////////////////////////////////////////////////////////////////////////
//
// Generic character set conversion function

//proc( "genericCsetFunc" )
procedure genericCsetFunc( var attr:attr_t in ebx; extended:boolean );
var
	tempStr	:string;

begin genericCsetFunc;

	push( eax );
	push( ecx );
	push( edx );

	// Convert the constant expression's value to a character:

	mov( attr, ebx );
	canAccess( [ebx] );
	movzx( attrEBX.pType, eax );
	switch( eax )


		// Just pass these types on through without conversion
		// assuming that the 128 bits represent the character set.

		case
		(
			Byte_pt,
			Word_pt,
			DWord_pt,
			QWord_pt,
			LWord_pt,  

			Uns8_pt,
			Uns16_pt,
			Uns32_pt,
			Uns64_pt,
			Uns128_pt, 

			Int8_pt,
			Int16_pt,
			Int32_pt,
			Int64_pt,
			Int128_pt  
		)


		// For characters, create the singleton set, if we're
		// within range:

		case( Char_pt, XChar_pt, Unicode_pt )

			movzx( attrEBX.word_vt, edx );
			mov (attr,ecx);
			zeroAttr([ecx]);
			//zeroAttr( attr );		// Start with empty set.

			// Handle xcset/cset here:

			mov( 127, ecx );
			if( extended ) then
			
				mov( 255, ecx );

			endif;
			if( edx <= ecx ) then

				// Create the singleton set:

				bts( edx, attrEBX.cset_vt );

			else

				HLAerror
				(
					"Cannot convert character to set, value out of range" nl
				);
				freeAttr( attrEBX );
				raise( ex.hlaerr );

			endif;


		case( String_pt, Utf8_pt )

			// Replace the pointer to the string with
			// the character set consisting of the
			// union of all the characters in the string.

			mov( attrEBX.string_vt, ecx );
			canAccess( [ecx] );

			// Clear the H.O. 128 bits because cs.strToCset won't do this:

			xor( eax, eax );
			mov( eax, attrEBX.dword_vt[16] );
			mov( eax, attrEBX.dword_vt[20] );
			mov( eax, attrEBX.dword_vt[24] );
			mov( eax, attrEBX.dword_vt[28] );

			// Convert string to cset. Note that this even works for
			// xcsets because strToCset doesn't check for character
			// values >= $80.
			cs.strToCset( ecx, attrEBX.cset_vt );
			strfree( ecx );

			// Determine if this is a cset or an xcset:

			mov( attrEBX.dword_vt[16], eax );
			or( attrEBX.dword_vt[20], eax );
			or( attrEBX.dword_vt[24], eax );
			or( attrEBX.dword_vt[28], eax );
			if( @nz ) then

				if( !extended ) then
				
					HLAerror
					(
						"String contains characters outside the range "
						"#$00..#$7f"
						nl
						"and cannot be converted to CSET"
						nl
					);
					raise( ex.hlaerr );

				endif;

			endif;
		case( UString_pt )		//26

			// Replace the pointer to the string with
			// the first character of the string, zero
			// extended to 32-bits.

			unicodeToAnsi( attrEBX.string_vt );
			if( @nc ) then

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );
				mov( attrEBX.string_vt, ecx );
				cs.strToCset( ecx, attrEBX.cset_vt );
				canAccess( [ecx] );
				strfree( ecx );
				// Determine if this is a cset or an xcset:

				mov( attrEBX.dword_vt[16], eax );
				or( attrEBX.dword_vt[20], eax );
				or( attrEBX.dword_vt[24], eax );
				or( attrEBX.dword_vt[28], eax );
				if( @nz ) then

					if( !extended ) then
					
						HLAerror
						(
							"String contains characters outside the range "
							"#$00..#$7f"
							nl
							"and cannot be converted to CSET"
							nl
						);
						raise( ex.hlaerr );

					endif;

				endif;
			else

				HLAerror
				( 
					"Unicode string could not be converted to a cset" nl
				);
				freeAttr( attrEBX );
				raise( ex.hlaerr );

			endif;

		case( XCset_pt )
			
			// If we're converting to a cset, make sure there are
			// no characters outside the range #$00..#$7f:

			if( !extended ) then

				// Determine if this is a cset or an xcset:

				mov( attrEBX.dword_vt[16], eax );
				or( attrEBX.dword_vt[20], eax );
				or( attrEBX.dword_vt[24], eax );
				or( attrEBX.dword_vt[28], eax );
				if( @nz ) then

					if( !extended ) then
					
						HLAerror
						(
							"String contains characters outside the range "
							"#$00..#$7f"
							nl
							"and cannot be converted to CSET"
							nl
						);
						raise( ex.hlaerr );

					endif;

				endif;

			endif;
		case( Cset_pt )

		   // Just return the existing cset...	


		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to character set form" 
				nl 
			);
			freeAttr( attrEBX );
			raise( ex.hlaerr );


	endswitch;
	if( extended ) then

		mov( XCset_pt, attrEBX.pType );
		mov( &xcset_ste, attrEBX.symType );

	else

		mov( Cset_pt, attrEBX.pType );
		mov( &cset_ste, attrEBX.symType );
		xor( eax, eax );
		mov( eax, attrEBX.dword_vt[16] );
		mov( eax, attrEBX.dword_vt[20] );
		mov( eax, attrEBX.dword_vt[24] );
		mov( eax, attrEBX.dword_vt[28] );

	endif;

	pop( edx );
	pop( ecx );
	pop( eax );

end genericCsetFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "cset( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "csetFunc" )
procedure csetFunc( var attr:attr_t );	
begin csetFunc;

	push( ebx );
	assert( attr <> NULL );
	genericCsetFunc( attr, false );
	pop( ebx );

end csetFunc;



///////////////////////////////////////////////////////////////////////////////
//
// Handle "xcset( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "xcsetFunc" )
procedure xcsetFunc( var attr:attr_t );	
begin xcsetFunc;

		
	push( ebx );
	assert( attr <> NULL );
	genericCsetFunc( attr, true );
	pop( ebx );

end xcsetFunc;


///////////////////////////////////////////////////////////////////////////////
//
// Handle "boolean( expr )" function here.
// Returns carry clear if successful, carry set if error.


//proc( "booleanFunc" )
procedure booleanFunc( var attr:attr_t );
begin booleanFunc;

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );


	// Convert the constant expression's value to an integer:

	mov( attr, ebx );
	canAccess( [ebx] );
	movzx( attrEBX.pType, eax );
	switch( eax )

		// For the integer types, 0= false, anything else is true.
		// We'll even throw boolean variables in here, even though
		// we should technically be able to pass them through unchanged.

		case
		(
			Byte_pt,			//0
			Word_pt,			//1
			DWord_pt,			//2
			QWord_pt,			//3
			TByte_pt,			//4
			LWord_pt,			//5

			Uns8_pt,			//6
			Uns16_pt,			//7
			Uns32_pt,			//8
			Uns64_pt,			//9
			Uns128_pt,			//10

			Int8_pt,			//11
			Int16_pt,			//12
			Int32_pt,			//13
			Int64_pt,			//14
			Int128_pt,			//15

			Boolean_pt			//20 
		)

			mov( attrEBX.dword_vt, eax );
			or( attrEBX.dword_vt[4], eax );
			or( attrEBX.dword_vt[8], eax );
			or( attrEBX.dword_vt[12], eax );
			or( attrEBX.dword_vt[16], eax );
			or( attrEBX.dword_vt[20], eax );
			or( attrEBX.dword_vt[24], eax );
			or( attrEBX.dword_vt[28], eax );
			setnz( al );
			movzx( al, eax );
			zeroAttr( [ebx] );
			mov( al, attrEBX.boolean_vt );


		// For strings, set the result to true if the
		// string is equal to "true" or "t", false if
		// the string contains anything else.

		case
		(
			String_pt,
			Utf8_pt,
			UString_pt
		)

			if( al = UString_pt ) then

				unicodeToAnsi( attrEBX.string_vt );
				if( @c ) then

					HLAerror
					( 
						"This unicode string cannot be converted to boolean"
						nl
					);
					freeAttr( attrEBX );
					raise( ex.hlaerr );

				endif;

			elseif( al = Utf8_pt ) then

				utf8ToAnsi( attrEBX.string_vt );
				if( @c ) then

					HLAerror
					( 
						"This UTF-8 string cannot be converted to boolean"
						nl
					);
					freeAttr( attrEBX );
					raise( ex.hlaerr );

				endif;

			endif;

			mov( attrEBX.string_vt, ecx );
			str.ieq( ecx, "true" );
			mov( eax, edx );
			str.ieq( ecx, "t" );		
			or( dl, al );
			zeroAttr( [ebx] );
			mov( al, attrEBX.boolean_vt );

			// Deallocate the string:

			strfree( ecx );



		// For characters, set the result to true if the
		// char is equal to 't', false if
		// the character is anything else.

		case
		(
			Char_pt,			//25
			XChar_pt,
			Unicode_pt			//26
		)

			movzx( attrEBX.word_vt, eax );
			zeroAttr( [ebx] );
			and( $FF5f, ax );
			cmp( ax, 'T' );
			sete( al );
			mov( al, attrEBX.boolean_vt );


		default

			HLAerror
			( 
				"Cannot convert type ", 
				pTypeStrs[ eax*4 ], 
				" to boolean form" 
				nl 
			);
			freeAttr( attrEBX );
			raise( ex.hlaerr );

	endswitch;
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );

	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
	clc();

end booleanFunc;






/*******************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
********************************************************************************
*******************************************************************************/


////////////////////////////////////////////////////////////////////////////////
//
// Compile-time functions.
//
//	Note that the dispatcher routine takes responsibility for preserving EAX,
// EBX, ECX, and EDX; so none of these routines need to preserve these
// registers.
//
//	All compile-time functions return the carry clear if they are successful,
// the return the carry set on error.
//
//	All compile-time functions place their result in the attr_t object passed
// as the parameter (assuming successful operation). They also parse up to
// (and including) the closing parenthesis. The caller must call lex to fetch
// the first lexeme following the closing parenthesis. Note that if there
// is a syntax error, all bets are off regarding where the parser stops. The
// caller should resync with the end of the line if that happens. If an error
// does occur, these routines set the attribute to an innocuous value (typically
// an UNS8 zero value).
//

////////////////////////////////////////////////////////////////////////////////
//
// ctAbs-
//
//	Handles the ABS(--) compile-time function.
//
//	Handles realXX, IntXX, and UnsXX values.
//	Note that hex values (byte, word, ...) are treated
//	as unsigned and all unsigned values are returned
//	unchanged (since, presumably, they are non-zero).

//proc( "ctAbs" )
procedure ctAbs( var attr:attr_t in ebx ); @noframe;
begin ctAbs;

	canAccess( [ebx] );
	matchLParen();
	jc badAbs;
	constExpr( [ebx] );
	mustMatchRParen();
	// Okay, syntactically it's correct, see if we can compute
	// the absolute value of the expression.

	movzx( attrEBX.pType, eax );
	switch( eax );

		case
		(
			Uns8_pt,
			Uns16_pt,
			Uns32_pt,
			Uns64_pt,
			Uns128_pt,
			Byte_pt,
			Word_pt,
			DWord_pt,
			QWord_pt,
			LWord_pt
		)
			/* Do nothing if unsigned value */


		// Negate the value if it's an int8, int16, ..., int128 value:
		// Note that we convert the value to unsigned after negating it.
		// This is a tricky way of dealing with overflow (that only
		// occurs when negating the most negative value).

		case( Int8_pt )

			mov( attrEBX.int8_vt, al );
			if( (type int8 al) < 0 ) then

				neg( al );
				mov( al, attrEBX.int8_vt );
				mov( Uns8_pt, attrEBX.pType );
				mov( &uns8_ste, attrEBX.symType );

			endif;
			xor( eax, eax );
			mov( al, attrEBX.int8_vt[1] );
			mov( ax, attrEBX.int16_vt[2] );
			mov( eax, attrEBX.int32_vt[4] );
			mov( eax, attrEBX.int32_vt[8] );
			mov( eax, attrEBX.int32_vt[12] );

		case( Int16_pt )

			mov( attrEBX.int16_vt, ax );
			if( (type int16 ax) < 0 ) then

				neg( ax );
				mov( ax, attrEBX.int16_vt );
				mov( Uns16_pt, attrEBX.pType );
				mov( &uns16_ste, attrEBX.symType );

			endif;
			xor( eax, eax );
			mov( ax, attrEBX.int16_vt[2] );
			mov( eax, attrEBX.int32_vt[4] );
			mov( eax, attrEBX.int32_vt[8] );
			mov( eax, attrEBX.int32_vt[12] );

		case( Int32_pt )

			mov( attrEBX.int32_vt, eax );
			if( (type int32 eax) < 0 ) then

				neg( eax );
				mov( eax, attrEBX.int32_vt );
				mov( Uns32_pt, attrEBX.pType );
				mov( &uns32_ste, attrEBX.symType );

			endif;
			xor( eax, eax );
			mov( eax, attrEBX.int32_vt[4] );
			mov( eax, attrEBX.int32_vt[8] );
			mov( eax, attrEBX.int32_vt[12] );

		case( Int64_pt )

			mov( attrEBX.int32_vt, eax );
			mov( attrEBX.int32_vt[4], edx );
			if( (type int32 edx) < 0 ) then

				neg( edx );
				neg( eax );
				sbb( 0, edx );
				mov( eax, attrEBX.int32_vt );
				mov( edx, attrEBX.int32_vt[4] );
				mov( Uns64_pt, attrEBX.pType );
				mov( &uns64_ste, attrEBX.symType );

			endif;
			xor( eax, eax );
			mov( eax, attrEBX.int32_vt[8] );
			mov( eax, attrEBX.int32_vt[12] );

		case( Int128_pt )

			cmp( attrEBX.byte_vt[15], 0 );
			if( @l ) then

				mov( 0, eax );
				sub( attrEBX.int32_vt, eax );
				mov( eax, attrEBX.int32_vt );

				mov( 0, eax );
				sbb( attrEBX.int32_vt[4], eax );
				mov( eax, attrEBX.int32_vt[4] );

				mov( 0, eax );
				sbb( attrEBX.int32_vt[8], eax );
				mov( eax, attrEBX.int32_vt[8] );

				mov( 0, eax );
				sbb( attrEBX.int32_vt[12], eax );
				mov( eax, attrEBX.int32_vt[12] );
				mov( Uns128_pt, attrEBX.pType );
				mov( &uns128_ste, attrEBX.symType );

			endif;


		// Negate the value if it is real:

		case( Real32_pt )

			finit();
			fclex();
			fld( attrEBX.real32_vt );
			fabs();
			fstp( attrEBX.real32_vt );

		case( Real64_pt )

			finit();
			fclex();
			fld( attrEBX.real64_vt );
			fabs();
			fstp( attrEBX.real64_vt );

		case( Real80_pt )

			finit();
			fclex();
			fld( attrEBX.real80_vt );
			fabs();
			fstp( attrEBX.real80_vt );


		// If it's not one of the above numeric types, then
		// we've got an error:

		default
			HLAerror( "Illegal operand type in @abs call" nl );
			raise( ex.hlaerr );
	endswitch;
	clc();
	ret();

badAbs:
	raise( ex.hlaerr );

end ctAbs;



///////////////////////////////////////////////////////////////////////////////
//
// ctArity-
//
//	Handle the @Arity(--) compile-time function.
// This function counts the number of array dimensions.
// If the specified parameter is not an array object, but is an otherwise
// legal expression, this function returns zero.

//proc( "ctArity" )
procedure ctArity( var attr:attr_t in ebx ); @noframe;
begin ctArity;

	canAccess( [ebx] );
	matchLParen();
	jc badArity2;
	constExpr( [ebx] );
	mustMatchRParen();
	mov( 0, edx );
	mov( attrEBX.symType, ecx );
	while( symECX.pType = Array_pt ) do

		inc( edx );
		mov( symECX.baseType, ecx );
		canAccess( [ecx] );

	endwhile;
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( edx, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	setSmallestSize( [ebx] );
	clc();
	ret();

badArity:
	freeAttr( [ebx] );
badArity2:
	raise( ex.hlaerr );

end ctArity;


///////////////////////////////////////////////////////////////////////////////
//
// ctBound-
//
//	Handles the @Bound compile-time variable in an expression.

//proc( "ctBound" )
procedure ctBound( var attr:attr_t in ebx ); @noframe;
begin ctBound;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( doBound, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctBound;


///////////////////////////////////////////////////////////////////////////////
//
// ctByte-
//
//	Handles the @Byte function.
//
//	@byte( expr )		-- Returns L.O. byte of expr.
//	@byte( expr, n )	-- Returns nth byte of expr (zero-based).

//proc( "ctByte" )
procedure ctByte( var attr:attr_t );
var
	index		:dword;
	whichByte	:attr_t;
begin ctByte;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );

	begin badctByte;

		// Eat the "(" and get the following expression:

		matchLParen();
		exitif( @c ) badctByte;
		constExpr( [ebx] );

		// We're only going to allow primitive types for this operator.

		mov( attrEBX.pType, al );
		if( !isPrimitive( al )) then

			HLAerror
			( 
				"@byte function only supports primitive data types"
				nl
			);
			freeAttr( attrEBX );
			raise( ex.hlaerr );

		endif;
		

		// If the second argument is not present, default to
		// returning the first byte of the expression:

		mov( 0, index );			// Default to first byte.

		// Check for optional second argument

		lex( esi );
		if( eax = ',' ) then

			// Okay, get the second argument and the closing parenthesis:

			constExpr( whichByte );
			mustMatchRParen();
			// Verify that the index value is reasonable:

			mov( whichByte.pType, al );
			if( !isSmallNum( al )) then

				HLAerror
				( 
					"Second argument to @byte must be a small number" 
					nl 
				);
				freeAttr( attrEBX );
				freeAttr( whichByte );
				raise( ex.hlaerr );

			endif;
			if
			( 
					(
							al = Int8_pt 
						&&	whichByte.int8_vt < 0
					)
				||	(
							al = Int16_pt 
						&&	whichByte.int8_vt[1] < 0
					)
				||	(
							al = Int32_pt 
						&&	whichByte.int8_vt[3] < 0
					)
			) then

				HLAerror
				(
					"Negative offset supplied as second argument to @byte"
					nl
				);
				freeAttr( attrEBX );
				freeAttr( whichByte );
				raise( ex.hlaerr );

			endif;
			mov( whichByte.uns32_vt, eax );
			mov( eax, index );

		elseif( eax <> ')' ) then

			HLAerror( "Syntax error in @byte, expected closing ')'" nl );
			freeAttr( attrEBX );
			freeAttr( whichByte );
			raise( ex.hlaerr );

		endif;

		// Okay, see if our index value is outside the range of the size
		// permitted by the first operand.

		mov( attr, ebx );
		mov( index, eax );
		if
		( 
				attrEBX.pType <> String_pt
			&&	attrEBX.pType <> UString_pt 
			&&	attrEBX.pType <> Utf8_pt 
		) then

			mov( attrEBX.symType, edx );
			canAccess( [edx] );
			if( eax >= symEDX.objectSize ) then

				HLAerror
				(
					"Index supplied (",
					(type uns32 eax ),
					") as second @byte argument must be "
					"less than " nl
					"object size (",
					symEDX.objectSize, 
					" bytes)"
					nl
				);
				freeAttr( attrEBX );
				freeAttr( whichByte );
				raise( ex.hlaerr );

			endif;

			// If we get here, things are okay. Extract the byte and return:

			mov( attrEBX.byte_vt[eax], cl );
			defaultAttr( [ebx] );	
			mov( cl, attrEBX.byte_vt );

		else // We've got a string, UTF-8 string, or a UString

			mov( attrEBX.string_vt, edx );
			canAccess( [edx] );
			if( eax >= (type str.strRec [edx]).length ) then

				HLAerror
				(
					"Second argument to @byte indexes beyond the "
					"end of the string supplied as 1st argument" nl
				);
				freeAttr( attrEBX );
				freeAttr( whichByte );
				raise( ex.hlaerr );

			endif;

			// If we get here, things are okay. Extract the byte from
			// the string (or UString) and return:

			mov( [edx + eax], cl );
			defaultAttr( [ebx] );	
			mov( cl, attrEBX.byte_vt );

		endif;
		mov( Byte_pt, attrEBX.pType );
		mov( &byte_ste, attrEBX.symType );
		clc();
		exit ctByte;

	end badctByte;

	// Drop down here if there was some sort of error.
	// (shouldn't actually get here, now).

	raise( ex.hlaerr );
		
end ctByte;




///////////////////////////////////////////////////////////////////////////////
//
// ctCeil-
//
//	Handles the @Ceil function.

//proc( "ctCeil" )
procedure ctCeil( var attr:attr_t in ebx ); @noframe;

	// ceil80 -
	//
	//	Computes the ceiling of the real80 value passed in as the parameter.
	// Leaves the 80-bit result on the FPU stack.

	procedure ceil80( src:real80 );
	var
		fcwSave:	word;
		fcw:		word;
		
	begin ceil80;
	
		fstcw( fcwSave );
		mov( fcwSave, ax );
		and( $f0ff, ax );
		or( $0b00, ax );
		mov( ax, fcw );
		fldcw( fcw );

		fld( src );
		frndint(); 	
		
		fldcw( fcwSave );
		
	end ceil80;

begin ctCeil;


	finit();
	fclex();
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Initialize the return value with all zeros:

	//zeroAttr( attr );
	zeroAttr(attrEBX);

	// Parse a constant expression as the parameter for this function.

	matchLParen();
	jc badCeil;
	//constExpr( attr );
	constExpr([ebx]);
	mustMatchRParen();
	// Convert the constant expression's value to a real80 value:

	makeReal80( attrEBX );

	fstp( attrEBX.real80_vt );

	// Compute the ceiling of this value:

	ceil80( attrEBX.real80_vt );
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	clc();
	ret();

badCeil:
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctCeil;


////////////////////////////////////////////////////////////////////////////////
//
// ctChar-
//
//	Handles the @Char function.

//proc( "ctChar" )
procedure ctChar( var attr:attr_t in ebx ); @noframe;
begin ctChar;

	assert( attr <> NULL );
	zeroAttr( attrEBX );
	constExpr( attrEBX );
	charFunc( attrEBX );
	ret();

end ctChar;



////////////////////////////////////////////////////////////////////////////////
//
// ctClass-
//
//	Handles the @Class function.
//
// Requires a single identifier, returns the identifier's class, which is
// one of the following values:
//
//			None_ct,		//0
//			Constant_ct,	//1
//			Value_ct, 		//2
//			Type_ct, 		//3
//			Var_ct,			//4
//			Parm_ct,		//5
//			Static_ct,		//6
//			Label_ct,		//7
//			Proc_ct,		//8
//			Iterator_ct,	//9
//			ClassProc_ct,	//10
//			ClassIter_ct,	//11
//			Method_ct,		//12
//			Macro_ct,		//13
//			Keyword_ct,		//14
//			Terminator_ct,	//15
//			Program_ct, 	//16
//			Namespace_ct,	//17
//			Symboltbl_ct,	//18
//			Segment_ct,		//19
//			Register_ct,	//20
//			Memory_ct,		//21 
//			Placeholder_ct	//22 


//proc( "ctClass" )
procedure ctClass( var attr:attr_t ); 
begin ctClass;
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@class expects an identifer as an argument" nl );
			getRightParen();
			raise( ex.hlaerr );
		endif;

		assert( tokenECX.isID );

		// If the "alloc" flag is true, then we need to
		// deallocate the storage assocated with the
		// identifier:

		if( tokenECX.alloc ) then

			assert( tokenECX.trueName <> NULL );
			assert( tokenECX.lcName <> NULL );
			strfree( tokenECX.trueName );
			strfree( tokenECX.lcName );

		endif;

		// If the lexer returns tkn_undefID, then
		// the symbol's class is cIllegal, else it is defined.

		if( eax = tkn_undefID ) then
		
			mov( None_ct, al );
		
		else
		
			mov( tokenECX.symNode, ecx );
			mov( symECX.symClass, al );
			
		endif;
		mov( attr, ebx );
		canAccess( [ebx] );
		mov( al, attrEBX.boolean_vt );
		mov( Uns8_pt, attrEBX.pType );
		mov( &uns8_ste, attrEBX.symType );
		mustMatchRParen();
		clc();

	endif;

end ctClass;



////////////////////////////////////////////////////////////////////////////////
//
// ctCos-
//
//	Handles the @Cos function.

//proc( "ctCos" )
procedure ctCos( var attr:attr_t in ebx ); @noframe;
begin ctCos;

	assert( attr <> NULL );
	finit();
	fclex();
	matchLParen();
	jc badCOS;
	constExpr( [ebx] );
	mustMatchRParen();
	//makeReal80( attr );
	freeAttr( attrEBX );
	fcos();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	clc();	
	ret();

badCOS:
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctCos;


////////////////////////////////////////////////////////////////////////////////
//
// ctCset-
//
//	Handles the @Cset function.

//proc( "ctCset" )
procedure ctCset( var attr:attr_t in ebx ); @noframe;
begin ctCset;

	assert( attr <> NULL );
	zeroAttr( attrEBX );
	constExpr( attrEBX );
	genericCsetFunc( attrEBX, false );
	ret();

end ctCset;


////////////////////////////////////////////////////////////////////////////////
//
// ctCurlex-
//
//	Handles the @Curlex function.

//proc( "ctCurlex" )
procedure ctCurlex( var attr:attr_t in ebx ); @noframe;
begin ctCurlex;

	assert( attr <> NULL );
	zeroAttr( attrEBX );
	mov( curLexLevel, eax );
	mov( eax, attrEBX.dword_vt );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	clc();
	ret();

end ctCurlex;


////////////////////////////////////////////////////////////////////////////////
//
// ctCurobj-
//
//	Handles the @Curobj function.

//proc( "ctCurobj" )
procedure ctCurobj( var attr:attr_t  ); 
begin ctCurobj;

	assert( attr <> NULL );
	zeroAttr( attr );
	if( curObject = NULL ) then
	
		str.a_cpy( "" );
		
	else
	
		mov( curObject, eax );
		str.a_cpy( symEAX.trueName );
		
	endif;
	mov( attr, ebx );
	mov( eax, attrEBX.string_vt );
	mov( String_pt, attrEBX.pType );
	mov( &string_ste, attrEBX.symType );
	clc();

end ctCurobj;

////////////////////////////////////////////////////////////////////////////////
//
// ctCuroffset-
//
//	Handles the @Curoffset function.

//proc( "ctCuroffset" )
procedure ctCuroffset( var attr:attr_t in ebx ); @noframe;
begin ctCuroffset;

	assert( attr <> NULL );
	zeroAttr( attrEBX );
	mov( curOffset, eax );
	mov( eax, attrEBX.dword_vt );
	mov( Int32_pt, attrEBX.pType );
	mov( &int32_ste, attrEBX.symType );
	clc();
	ret();

end ctCuroffset;


////////////////////////////////////////////////////////////////////////////////
//
// ctDate-
//
//	Handles the @Date function.

//proc( "ctDate" )
procedure ctDate( var attr:attr_t );
var
	theDate	:date.daterec;

begin ctDate;

	assert( attr <> NULL );
	zeroAttr( attr );
	date.setFormat( date.yyyymmdd );
	date.setSeparator( '/' );
	date.today( theDate );
	date.a_toString( theDate );
	mov( attr, ebx );
	mov( eax, attrEBX.string_vt );
	mov( String_pt, attrEBX.pType );
	mov( &string_ste, attrEBX.symType );
	clc();

end ctDate;


////////////////////////////////////////////////////////////////////////////////
//
// ctDefined-
//
//	Handles the @Defined function.

//proc( "ctDefined" )
procedure ctDefined( var attr:attr_t );
begin ctDefined;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@defined expects an identifer as an argument" nl );
			getRightParen();
			raise( ex.hlaerr );

		endif;

		assert( tokenECX.isID );

		// If the "alloc" flag is true, then we need to
		// deallocate the storage assocated with the
		// identifier:

		if( tokenECX.alloc ) then

			assert( tokenECX.trueName <> NULL );
			assert( tokenECX.lcName <> NULL );
			strfree( tokenECX.trueName );
			strfree( tokenECX.lcName );

		endif;

		// If the lexer returns tkn_undefID, then
		// the symbol is undefined, else it is defined.

		cmp( eax, tkn_undefID );
		setne( al );
		mov( attr, ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		mustMatchRParen();
	endif;

end ctDefined;



////////////////////////////////////////////////////////////////////////////////
//
// ctDelete-
//
//	Handles the @Delete function.

//proc( "ctDelete" )
procedure ctDelete( var attr:attr_t );
var
	saveESI	:dword;
	saveEDI	:dword;
	start	:attr_t;
	length	:attr_t;

begin ctDelete;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( start );
	defaultAttr( length );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( start );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( length );
			exitif( @c ) error;
			mustMatchRParen();
			// Okay, do the string deletion operation:

			try

				mov( esi, saveESI );
				mov( edi, saveEDI );
				mov( attr, ebx );
				if( attrEBX.pType = Utf8_pt ) then

					// If it's UTF-8, then treat the multi-byte characters
					// as single characters.

					utf8Index( attrEBX.string_vt, start.uns32_vt );
					mov( eax, start.uns32_vt );
					utf8Index2( attrEBX.string_vt, length.uns32_vt, eax );
					mov( eax, length.uns32_vt );

				endif;
				str.delete( attrEBX.string_vt, start.uns32_vt, length.uns32_vt );
				
			  exception( ex.MemoryAllocationFailure )

				raise( ex.MemoryAllocationFailure );
			
			  anyexception
			  
				// This really can't happen, but just in case str.delete
				// changes.

				mov( saveEDI, edi );
				mov( saveESI, esi );
			  	HLAerror( "Illegal @delete arguments" nl );
			  	raise( ex.hlaerr );
			  	
			endtry;
			clc();
			exit noerror;  
			
		end error;
		freeAttr( start );
		freeAttr( length );
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctDelete;




///////////////////////////////////////////////////////////////////////////////
//
// ctDim-
//
//	Handles the @Dim function.
// This returns an array of integers with each element containing a bound
// of the dimensions of the array.

//proc( "ctDim" )
procedure ctDim( var attr:attr_t );
var
	expr		:attr_t;
	dummy		:symNodePtr_t;
	symType		:symNodePtr_t;
	symbol		:symNodePtr_t;
	idStart		:dword;
	idEnd		:dword;
	dimStr		:string;
	pbStr		:string;

begin ctDim;

	assert( attr <> NULL );
	str.talloc( 32 );
	mov( eax, dimStr );
	defaultAttr( expr );
	defaultAttr( attr );
	begin noerror;

		begin error;

			matchLParen();
			raiseErr( @c );

			// Check to see if we've got a symbol:

			begin getObjType;

				lex( esi );
				if( ebx = ID_tc ) then

					// Save pointers to the beginning and end of the ID in
					// memory in case we have to back up and reuse this
					// identifier:

					mov( esi, idEnd );
					mov( edi, idStart );
					mov( tokenECX.symNode, eax );
					mov( eax, symbol );

					// If we've got an identifier, it could be a type,
					// variable, or other non-constant object, for whom
					// we could still compute an @dim value:

					lex( esi );
					if( eax = ')' ) then

						// Okay, we've got a simple identifier.
						// If it's not a constant object, then we'll
						// use it's type directly.

						mov( symbol, ebx );
						canAccess( [ebx] );
						mov( symEBX.symClass, al );
						if( al not in Constant_ct..Static_ct ) then

							HLAerror( "@dim expected an array operand" nl );
							raise( ex.hlaerr );

						endif;
						if( al <> Type_ct ) then

							// If it's not a type object, then grab
							// the type field:

							mov( symEBX.symType, ebx );

						endif;
						mov( ebx, symType );
						exit getObjType; 

					endif;

					// Horrible kludge! In order to fake two symbols
					// of lookahead (which we need), we'll just
					// create a string consisting of the identifier and
					// the current symbol and push all that back onto the
					// lexer's input stream.
					//
					//	WARNING! This creates a memory leak as we have
					// to leave the allocated storage laying around.
					// Fortunately, this won't be a problem as @dim
					// doesn't get used that often.

					mov( esi, eax );	// Compute length of current lexeme.
					sub( edi, eax );
					mov( eax, edx );	// Save for later

					mov( idEnd, ecx );	// Factor in length of identifier
					sub( idStart, ecx );
					add( eax, ecx );

					inc( ecx );			// Include room for space between them.

					stralloc( eax );	// Create room for string.
					mov( eax, pbStr );
					mov( ecx, (type str.strRec [eax]).length );
					push( esi );
					push( edi );

					// Copy original identifier:

					mov( idStart, esi );
					mov( eax, edi );
					rep.movsb();

					// Separate the two with a space:

					mov( ' ', (type char [edi]));
					inc( edi );

					// Now copy the current lexeme:

					mov( [esp], esi );	// Pointer to start of current lexeme.
					mov( edx, ecx );	// Length of current lexeme
					rep.movsb();

					// Zero-terminate string:

					mov( #0, (type char [edi]));

					// Push it back so we re-lex it:

					pushBackStr( pbStr );

				endif;

				constExpr( expr );
				mov( expr.symType, ecx );
				mov( ecx, symType );
				mustMatchRParen();

			end getObjType;

			// Compute the number of dimensions:

			mov( 0, edx );
			mov( symType, ecx );
			canAccess( [ecx] );
			while( symECX.pType = Array_pt ) do

				inc( edx );
				mov( symECX.baseType, ecx );
				canAccess( [ecx] );

			endwhile;
			if( edx = 0 ) then

				HLAerror( "@dim expected an array operand" nl );
				raise( ex.hlaerr );
			endif;

			// Create a dummy symbol table entry to hold
			// the number of dimensions. We're not really
			// going to enter this into the symbol table,
			// but we need it for the following constant.
			// Too bad, the memory for this is never recovered
			// (i.e., this is a memory leak). Fortunately, the
			// @dim function doesn't get called very often, so
			// this is no big deal.

			str.put( dimStr, "@string[", (type uns32 edx), ']' );
			str.a_cpy( dimStr );
			mov( eax, ecx );
			malloc( @size( symNode_t ));
			mov( eax, dummy );

			mov( ecx, symEAX.trueName );
			mov( ecx, symEAX.lcName );
			mov( &uns32_ste, symEAX.baseType );
			mov( Array_pt, symEAX.pType );
			mov( Type_ct, symEAX.symClass );
			mov( curHashTable, ecx );
			mov( hashECX.owner, ecx );
			mov( ecx, symEAX.owner );
			mov( curLexLevel, symEAX.lexLevel );
			lea( ecx, [edx*4] );
			mov( ecx, symEAX.objectSize );
			mov( false, symEAX.isExternal );
			mov( false, symEAX.isPublic );
			mov( false, symEAX.isReferenced );
			mov( false, symEAX.isForward );
			mov( false, symEAX.isPrivate );
			mov( false, symEAX.isReadOnly );
			mov( notp_pc, symEAX.pClass );
			mov( _none, symEAX.inReg );
			mov( NULL, symEAX.externName );
			mov( 0, symEAX.offset );
			mov( edx, symEAX.numElements );

			// Okay, create an array of attr_t objects to
			// hold the array dimensions:

			intmul( @size( attr_t ), edx, eax );
			malloc( eax );

			// Initialize the attr object to be an array of
			// uns32 values:

			mov( attr, ecx );
			canAccess( [ecx] );
			mov( dummy, attrECX.symType );
			mov( Deferred_pt, attrECX.pType );
			mov( Constant_ct, attrECX.symClass );
			mov( eax, attrECX.arrayValues_vt );
			mov( edx, attrECX.numElements );

			// Okay, set the values for each of these attr objects
			// to the bounds value for their corresponding dimension:

			mov( symType, ecx );
			canAccess( [ecx] );
			mov( eax, ebx );
			while( symECX.pType = Array_pt ) do

				defaultAttr( [ebx] );
				mov( Uns32_pt, attrEBX.pType );
				mov( &uns32_ste, attrEBX.symType );
				mov( Constant_ct, attrEBX.symClass );
				mov( symECX.numElements, eax );
				mov( eax, attrEBX.uns32_vt );
				add( @size( attr_t ), ebx );
				mov( symECX.baseType, ecx );
				canAccess( [ecx] );

			endwhile;
			clc();
			exit noerror;						

		end error;
		freeAttr( attrEBX );
		freeAttr( expr );
		raise( ex.hlaerr );

	end noerror;

end ctDim;


////////////////////////////////////////////////////////////////////////////////
//
// ctDisplay-
//
//	Handles the @Display function.

//proc( "ctDisplay" )
procedure ctDisplay( var attr:attr_t in ebx ); @noframe;
begin ctDisplay;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultDisplay, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctDisplay;



////////////////////////////////////////////////////////////////////////////////
//
// ctDword-
//
//	Handles the @Dword function.
//
//	@dword( expr ) -	Returns the first dword of the specified expression
//	@dword( expr, n ) -	Returns the dword at byte offset n of the 
//						 specified expression
//
//	Returns carry set if error, carry clear if successful.

//proc( "ctDword" )
procedure ctDword( var attr:attr_t );
var
	index		:dword;
	whichDWord	:attr_t;

begin ctDword;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@dword function only supports primitive data types"
					nl
				);
				freeAttr( attrEBX );
				raise( ex.hlaerr );
			endif;
			

			// If the second argument is not present, default to
			// returning the first dword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichDWord );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichDWord.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @dword must be a small number" 
						nl 
					);
					freeAttr( attrEBX );
					freeAttr( whichDWord );
					raise( ex.hlaerr );

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichDWord.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichDWord.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichDWord.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @dword"
						nl
					);
					freeAttr( attrEBX );
					freeAttr( whichDWord );
					raise( ex.hlaerr );

				endif;
				mov( whichDWord.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @dword, expected closing ')'" nl );
				freeAttr( attrEBX );
				raise( ex.hlaerr );

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as (optional) second @dword argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					freeAttr( attrEBX );
					raise( ex.hlaerr );

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an DWORD object,
				// we only need to transfer 4 bytes, so compute
				// the minimum of objectsize-index and 4 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 4 ) then

					mov( 4, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the DWORD,
				// if the original data type (plus the index) had
				// fewer than 4 bytes:

				while( edx < 4 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the LWORD:

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );


			else // We've got a string, UTF-8 string, or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				if( eax >= (type str.strRec [edx]).length ) then

					HLAerror
					(
						"Second argument to @dword indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					freeAttr( attrEBX );
					raise( ex.hlaerr );

				endif;

				// We're going to transfer a minimum of 4 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 4 ) then

					mov( 4, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the DWORD,
				// if the original data type (plus the index) had
				// fewer than 4 bytes:

				while( esi < 4 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( DWord_pt, attrEBX.pType );
			mov( &dword_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctDword;


////////////////////////////////////////////////////////////////////////////////
//
// ctElements-
//
//	Handles the @Elements function.

//proc( "ctElements" )
procedure ctElements( var attr:attr_t in ebx ); @noframe;
begin ctElements;

	canAccess( [ebx] );
	defaultAttr( attrEBX );
	begin noerror;

		begin error;

			// Note: grabbing the expression in the parentheses
			// will automatically compute the number of elements for us.

			matchLParen();
			exitif( @c ) error;
			constExpr( attrEBX );
			mustMatchRParen();
			// Get the number of elements, and then free up
			// the storage used by the array constant:

			mov( 0, eax ); // Assume it's not an array.
			if( attrEBX.pType = Array_pt ) then

				mov( attrEBX.numElements, eax );

			endif;
			freeAttr( attrEBX );

			// Set the result type to uns32 and return the number
			// of elements as the result:

			defaultAttr( attrEBX );
			mov( eax, attrEBX.uns32_vt );
			 
			clc();
			exit noerror;						

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	ret();

end ctElements;



////////////////////////////////////////////////////////////////////////////////
//
// ctElementSize-
//
//	Handles the @ElementSize function.

//proc( "ctElementSize" )
procedure ctElementSize( var attr:attr_t in ebx ); @noframe;
begin ctElementSize;

	canAccess( [ebx] );
	defaultAttr( attrEBX );
	begin noerror;

		begin error;

			// Note: grabbing the expression in the parentheses
			// will automatically compute the size of the elements for us.

			matchLParen();
			exitif( @c ) error;
			constExpr( attrEBX );
			mustMatchRParen();
			// Determine the base element type of the array:

			mov( attrEBX.symType, eax );
			canAccess( [eax] );
			while( symEAX.pType = Array_pt ) do

				mov( symEAX.baseType, eax );
				canAccess( [eax] );

			endwhile;
			getBaseIsoType( eax );
			canAccess( [eax] );

			// Get the size of the elements, and then free up
			// the storage used by the array constant:

			mov( symEAX.objectSize, eax );
			freeAttr( attrEBX );

			// Set the result type to uns32 and return the number
			// of elements as the result:

			defaultAttr( attrEBX );
			mov( eax, attrEBX.uns32_vt );
			 
			clc();
			exit noerror;						

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	ret();

end ctElementSize;


////////////////////////////////////////////////////////////////////////////////
//
// ctEnter-
//
//	Handles the @Enter function.

//proc( "ctEnter" )
procedure ctEnter( var attr:attr_t in ebx ); @noframe;
begin ctEnter;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultEnter, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctEnter;


////////////////////////////////////////////////////////////////////////////////
//
// ctEnumSize-
//
//	Handles the @EnumSize function.

//proc( "ctEnumSize" )
procedure ctEnumSize( var attr:attr_t in ebx ); @noframe;
begin ctEnumSize;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Uns8_pt, attrEBX.pType );
	mov( &uns8_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( curEnumSize, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctEnumSize;


////////////////////////////////////////////////////////////////////////////////
//
// ctEOS-
//
//	Handles the @EOS function.
//
//	@EOS( string ) - Returns true if "string" is empty, false otherwise

//proc( "ctEOS" )
procedure ctEOS( var attr:attr_t in ebx ); @noframe;
begin ctEOS;

	canAccess( [ebx] );
	defaultAttr( attrEBX );
	begin noerror;

		begin error;

			// Note: grabbing the expression in the parentheses.

			matchLParen();
			exitif( @c ) error;
			constExpr( attrEBX );
			mustMatchRParen();
			if( attrEBX.pType <> String_pt ) then

				HLAerror
				(
					"Expected a string expression for @EOS argument" nl
				);
				exit error;

			endif;

			mov( attrEBX.string_vt, eax );
			canAccess( [eax] );
			push( eax );
			cmp( (type char [eax]), #0 );
			sete( al );
			movzx( al, eax );
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( Constant_ct, attrEBX.symClass );
			mov( eax, attrEBX.dword_vt );
			mov( 0, attrEBX.dword_vt[4] );
			mov( 0, attrEBX.dword_vt[8] );
			mov( 0, attrEBX.dword_vt[12] );
			pop( eax );
			str.free( eax );
			clc();
			ret();
			 
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;
	ret();


end ctEOS;


////////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNChar-
//
//	Handles the @ExactlyNChar function.
//
// @ExactlyNChar( string, char, n ):
//		Returns true if string begins with exactly n char characters and 
//		the n+1st character is not equal to char.
//
// @ExactlyNChar( string, char, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @ExactlyNChar( string, char, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.

//proc( "ctExactlyNChar" )
procedure ctExactlyNChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @ExactlyNChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@ExactlyNChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @ExactlyNChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					cmp( al, [edx+ecx] );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is different:
				
				cmp( al, [edx+ecx] );
				exitif( @e ) rtnFalse;

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctExactlyNChar;



///////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNCset-
//
//	Handles the @ExactlyNCset function.
//
// @ExactlyNCset( string, cset, n ):
//		Returns true if string begins with exactly n characters from cset and 
//		the n+1st character is not in cset.
//
// @ExactlyNCset( string, cset, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @ExactlyNCset( string, cset, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.

//proc( "ctExactlyNCset" )
procedure ctExactlyNCset( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theCset			:attr_t;
	n				:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @ExactlyNCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@ExactlyNCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @ExactlyNCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					// See if the current character is in the set:

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					exitif( @nc ) rtnFalse;
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is different:
				
				movzx( (type char [edx+ecx]), eax );
				bt( eax, theCset.cset_vt );
				exitif( @c ) rtnFalse;

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctExactlyNCset;


////////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNIChar-
//
//	Handles the @ExactlyNIChar function.
//
// @ExactlyNIChar( string, char, n ):
//		Returns true if string begins with exactly n char characters (case
//		insenstive comparison) and the n+1st character is not equal to char.
//
// @ExactlyNIChar( string, char, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @ExactlyNIChar( string, char, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.


//proc( "ctExactlyNIChar" )
procedure ctExactlyNIChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @ExactlyNChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@ExactlyNChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @ExactlyNChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:
				// Don't use the toUpper macro here,
				// 'cause it doesn't check the full range.

				mov( theChar.char_vt, ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;


				mov( 0, ecx );
				mov( attr, ebx );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					mov( [edx+ecx], al );
					toUpper( al );
					cmp( al, ah );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is different:
				
				mov( [edx+ecx], al );
				toUpper( al );
				cmp( al, ah );
				exitif( @e ) rtnFalse;

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctExactlyNIChar;


///////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNToMChar-
//
//	Handles the @ExactlyNToMChar function.
//
// @ExactlyNToMChar( string, char, n ):
//		Returns true if string begins with between n and m char characters.
//
// @ExactlyNToMChar( string, char, n, remainder )
//		As above, but returns the remainder of the string.
//
// @ExactlyNToMChar( string, char, n, remainder, matched )
//		As above, but returns the matched characters in the "matched" variable.

//proc( "ctExactlyNToMChar" )
procedure ctExactlyNToMChar( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theChar			:attr_t;
	n				:attr_t;
	m				:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNToMChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@ExactlyNToMChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@ExactlyNToMChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ExactlyNToMChar - expected a ')'" 
					nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( ecx < n.uns32_vt ) do

					cmp( al, [edx+ecx] );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;

				// Okay, we've matched at least n characters, so we're
				// succeeded thus far, now let's match up to m chars:

				while( ecx < m.uns32_vt ) do

					cmp( al, [edx+ecx] );
					breakif( @ne );
					inc( ecx );
					
				endwhile;
				exitif( ecx = m.uns32_vt && al = [edx+ecx] ) rtnFalse;
				

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, edx );
				canAccess( [edx] );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symEDX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				str.a_cpy( "" );
				mov( eax, symEDX.va.string_vt );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctExactlyNToMChar;



///////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNToMCset-
//
//	Handles the @ExactlyNToMChar function.
//
// @ExactlyNToMCset( string, cset, n ):
//		Returns true if string begins with between n and m characters in cset.
//
// @ExactlyNToMCset( string, cset, n, remainder )
//		As above, but returns the remainder of the string.
//
// @ExactlyNToMCset( string, cset, n, remainder, matched )
//		As above, but returns the matched characters in the "matched" variable.

//proc( "ctExactlyNToMCset" )
procedure ctExactlyNToMCset( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theCset			:attr_t;
	n				:attr_t;
	m				:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNToMCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@ExactlyNToMCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@ExactlyNToMCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ExactlyNToMCset - expected a ')'" 
					nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					exitif( @nc ) rtnFalse;
					inc( ecx );
					
				endwhile;

				// Okay, we've matched at least n characters, so we're
				// succeeded thus far, now let's match up to m chars:

				while( ecx < m.uns32_vt ) do

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					breakif( @nc );
					inc( ecx );
	
				endwhile;
				if( ecx = m.uns32_vt ) then

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					exitif( @c ) rtnFalse;

				endif;
				

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, edx );
				canAccess( [edx] );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symEDX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				str.a_cpy( "" );
				mov( eax, symEDX.va.string_vt );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctExactlyNToMCset;







///////////////////////////////////////////////////////////////////////////////
//
// ctExactlyNToMIChar-
//
//	Handles the @ExactlyNToMIChar function.
//
// @ExactlyNToMIChar( string, char, n ):
//		Returns true if string begins with between n and m char characters
//		using a case insensitive comparison.
//
// @ExactlyNToMIChar( string, char, n, remainder )
//		As above, but returns the remainder of the string.
//
// @ExactlyNToMIChar( string, char, n, remainder, matched )
//		As above, but returns the matched characters in the "matched" variable.

//proc( "ctExactlyNToMIChar" )
procedure ctExactlyNToMIChar( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theChar			:attr_t;
	n				:attr_t;
	m				:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctExactlyNToMIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@ExactlyNToMIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@ExactlyNToMIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ExactlyNToMIChar - expected a ')'" 
					nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:
				//
				// Force the char to uppercase:

				mov( theChar.char_vt, ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;
				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					mov( [edx+ecx], al );
					toUpper( al );
					cmp( al, ah );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;

				// Okay, we've matched at least n characters, so we're
				// succeeded thus far, now let's match up to m chars:

				while( ecx < m.uns32_vt ) do

					mov( [edx+ecx], al );
					toUpper( al );
					cmp( al, ah );
					breakif( @ne );
					inc( ecx );
					
				endwhile;
				if( ecx = m.uns32_vt ) then

					mov( [edx+ecx], al );
					toUpper( al );
					exitif( al = ah ) rtnFalse;

				endif;
				

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, edx );
				canAccess( [edx] );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symEDX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				str.a_cpy( "" );
				mov( eax, symEDX.va.string_vt );
				mov( &string_ste, symEDX.symType );
				mov( String_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctExactlyNToMIChar;


//////////////////////////////////////////////////////////////////////////////
//
// ctExp-
//
//	Handles the @Exp function.
//
//	@exp( numeric_value );
//
//	Returns e^numeric_value.

//proc( "ctExp" )
procedure ctExp( var attr:attr_t in ebx ); @noframe;
begin ctExp;

	assert( attr <> NULL );
	finit();
	fclex();
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		// Convert the constant expression's value to a real80 value:

		finit();
		fclex();
		makeReal80( attrEBX );

		// Compute e^n of this value:

		math.exp();
		fstp( attrEBX.real80_vt );
		mov( Real80_pt, attrEBX.pType );
		mov( &real80_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctExp;


///////////////////////////////////////////////////////////////////////////////
//
// ctExtract-
//
//	Handles the @Extract function.

//proc( "ctExtract" )
procedure ctExtract( var attr:attr_t in ebx ); @noframe;
begin ctExtract;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		getCset( attrEBX );
		exitif( @c ) error;
		mustMatchRParen();
		// Okay, at this point attr contains a valid CSET.
		// return the first set bit in the cset. Note that
		// the following call to cs.extract does *not* affect
		// the original character set (we're working on a copy here).

		cs.extract( attrEBX.cset_vt );
		defaultAttr( attrEBX );
		mov( al, attrEBX.char_vt );
		mov( Char_pt, attrEBX.pType );
		mov( &char_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctExtract;


////////////////////////////////////////////////////////////////////////////////
//
// ctFilename-
//
//	Handles the @Filename function.

//proc( "ctFilename" )
procedure ctFilename( var attr:attr_t in ebx ); @noframe;
begin ctFilename;

	assert( attr <> NULL );
	defaultAttr( attrEBX );
	mov( &string_ste, attrEBX.symType );
	mov( String_pt, attrEBX.pType );
	str.a_cpy( filename );
	mov( eax, attrEBX.string_vt );
	clc();
	ret();

end ctFilename;


////////////////////////////////////////////////////////////////////////////////
//
// ctFirstNChar-
//
//	Handles the @FirstNChar function.
//
// @FirstNChar( string, char, n ):
//		Returns true if string begins with n char characters.
//
// @FirstNChar( string, char, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @FirstNChar( string, char, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.

//proc( "ctFirstNChar" )
procedure ctFirstNChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctFirstNChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @FirstNChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@FirstNChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @FirstNChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					cmp( al, [edx+ecx] );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctFirstNChar;





////////////////////////////////////////////////////////////////////////////////
//
// ctFirstNIChar-
//
//	Handles the @FirstNIChar function.
//
// @FirstNIChar( string, char, n ):
//		Returns true if string begins with n char characters (case
//		insenstive comparison).
//
// @FirstNIChar( string, char, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @FirstNIChar( string, char, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.


//proc( "ctFirstNIChar" )
procedure ctFirstNIChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctFirstNIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @FirstNIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@FirstNIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @FirstNIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:
				// Don't use the toUpper macro here,
				// 'cause it doesn't check the full range.

				mov( theChar.char_vt, ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;


				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					mov( [edx+ecx], al );
					toUpper( al );
					cmp( al, ah );
					exitif( @ne ) rtnFalse;
					inc( ecx );
					
				endwhile;
				
				// Okay, we've matched n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctFirstNIChar;


////////////////////////////////////////////////////////////////////////////////
//
// ctFirstNCset-
//
//	Handles the @FirstNCset function.
//
// @FirstNCset( string, cset, n ):
//		Returns true if string begins with exactly n characters from cset.
//
// @FirstNCset( string, cset, n, remainder )
//		As above, but returns the remainder of the string (after matching
//		n characters) in the "remainder" variable.
//
// @FirstNCset( string, cset, n, remainder, matched )
//		As above, but returns the n matched characters in the "matched" variable.

//proc( "ctFirstNCset" )
procedure ctFirstNCset( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theCset			:attr_t;
	n				:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctFirstNCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth @FirstNCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@FirstNCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @FirstNCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					// See if the current character is in the set:

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					exitif( @nc ) rtnFalse;
					inc( ecx );
					
				endwhile;
				

				// We'll, we've matched all the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					sub( n.uns32_vt, eax );
					str.a_substr( attrEBX.string_vt, n.uns32_vt, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, n.uns32_vt );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctFirstNCset;


////////////////////////////////////////////////////////////////////////////////
// ctFloor-
//
//	Handles the @Floor function.

//proc( "ctFloor" )
procedure ctFloor( var attr:attr_t in ebx ); @noframe;

	// Floor80 - Computes the largest integer smaller than
	// the value passed as the parameter and leaves it on the
	// FPU stack:

	procedure floor80( src:real80 ); @nodisplay; @noframe;
	static
		fcwSave:	word;
		fcw:		word;
		
	begin floor80;

		push( ebp );
		mov( esp, ebp );
		
		fstcw( fcwSave );
		mov( fcwSave, ax );
		and( $f0ff, ax );
		or( $0700, ax );
		mov( ax, fcw );
		fldcw( fcw );

		fld( src );
		frndint(); 	
		
		fldcw( fcwSave );
		pop( ebp );
		ret( 12 );
		
	end floor80;

begin ctFloor;


	finit();
	fclex();
	mov( attr, ebx );
	canAccess( [ebx] );
		
	// Initialize the return value with all zeros:

	zeroAttr( attrEBX );

	// Parse a constant expression as the parameter for this function.

	matchLParen();
	jc badFloor;
	constExpr( attrEBX );
	mustMatchRParen();
	// Convert the constant expression's value to a real80 value:

	makeReal80( attrEBX );
	fstp( attrEBX.real80_vt );

	// Compute the ceiling of this value:

	floor80( attrEBX.real80_vt );
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	ret();

badFloor:
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctFloor;


////////////////////////////////////////////////////////////////////////////////
//
// ctFrame-
//
//	Handles the @Frame function (which returns the compile-time defaultFrame
// variable's value).

//proc( "ctFrame" )
procedure ctFrame( var attr:attr_t in ebx ); @noframe;
begin ctFrame;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultFrame, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctFrame;


////////////////////////////////////////////////////////////////////////////////
//
// ctIndex-
//
//	Handles the @Index function.
//
//	@index( strExpr1, startIndex, strExpr2 );
//
//	Searches for strExpr2 within strExpr1 starting at index startIndex.

//proc( "ctIndex" )
procedure ctIndex( var attr:attr_t );
var
	strExpr1	:attr_t;
	strExpr2	:attr_t;

begin ctIndex;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr1 );
	defaultAttr( strExpr2 );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr1 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( strExpr2 );
			exitif( @c ) error;
			mustMatchRParen();

			mov( attr, ebx );
			if( strExpr1.pType = Utf8_pt ) then

				// If it's UTF-8, then treat the multi-byte characters
				// as single characters.

				utf8Index( strExpr1.string_vt, attrEBX.uns32_vt );
				mov( eax, attrEBX.uns32_vt );

			endif;
			// Use the HLA stdlib INDEX function to
			// compute the result:

			str.index3
			( 
				strExpr1.string_vt, 
				attrEBX.uns32_vt, 
				strExpr2.string_vt 
			);
			mov( eax, attrEBX.uns32_vt );

			// If strExpr1 is a UTF-8 string, then we may need to adjust
			// the index to skip over multi-byte characters.

			if( strExpr1.pType = Utf8_pt ) then

				// If it's UTF-8, then treat the multi-byte characters
				// as single characters.

				utf8Index( strExpr1.string_vt, attrEBX.uns32_vt );
				sub( attrEBX.uns32_vt, eax );
				sub( eax, attrEBX.uns32_vt );

			endif;


			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	pushfd();
	freeAttr( strExpr1 );
	freeAttr( strExpr2 );
	popfd();

end ctIndex;



////////////////////////////////////////////////////////////////////////////////
//
// ctInsert-
//
//	Handles the @Insert function.
//
//	@insert( str1, ndx, str2 );
//
// 	Returns a string with str2 inserted into str1 at position ndx 

//proc( "ctInsert" )
procedure ctInsert( var attr:attr_t );
var
	strExpr1	:attr_t;
	strExpr2	:attr_t;
	ndx			:attr_t;

begin ctInsert;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr1 );
	defaultAttr( strExpr2 );
	defaultAttr( ndx );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr1 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( strExpr2 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( ndx );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.insert function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			if( strExpr2.pType = Utf8_pt ) then

				utf8Index( strExpr2.string_vt, ndx.uns32_vt );
				mov( eax, ndx.uns32_vt );

			endif;
 
			str.a_insert
			( 
				strExpr1.string_vt,
				ndx.uns32_vt, 
				strExpr2.string_vt 
			);
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	pushfd();
	freeAttr( strExpr1 );
	freeAttr( strExpr2 );
	freeAttr( ndx );
	popfd();

end ctInsert;



///////////////////////////////////////////////////////////////////////////////
//
// ctIntFunc - Does a conversion to an integer for the ctIntXXX functions.

//proc( "ctIntFunc" )
procedure ctIntFunc( var attr:attr_t );
var
	cwSave	:word;
	newCW	:word;
	sign	:boolean;

begin ctIntFunc;

	assert( attr <> NULL );
	begin noerror;

		begin error;

			// Initialize the return value with all zeros:

			zeroAttr( attr );

			// Parse a constant expression as the parameter for this function.

			matchLParen();
			exitif( @c ) error;
			constExpr( attr );
			mustMatchRParen();
			// Convert the constant expression's value to an integer:

			mov( attr, ebx );
			canAccess( [ebx] );
			movzx( attrEBX.pType, eax );
			switch( eax )

				// Just pass these types on through without conversion
				// They're already integers. So let the caller handle
				// range checking and stuff like that.

				case
				(
					Byte_pt,   
					Word_pt,   
					DWord_pt,  
					QWord_pt,  
					TByte_pt,  
					LWord_pt,  

					Uns8_pt,   
					Uns16_pt,  
					Uns32_pt,  
					Uns64_pt,  
					Uns128_pt, 

					Int8_pt,   
					Int16_pt,  
					Int32_pt,  
					Int64_pt,  
					Int128_pt, 

					Real32_pt, 
					Real64_pt, 

					Boolean_pt, 
					Enum_pt,   

					Char_pt,   
					XChar_pt,  
					Unicode_pt,

					Cset_pt,
					XCset_pt
				)

					/* do nothing if one of the above cases */



				case( Real80_pt )

					// Zero out any H.O. bytes:

					mov( 0, attrEBX.word_vt[10] );
					mov( 0, attrEBX.dword_vt[12] );



				case
				(
					String_pt,
					Utf8_pt,
					UString_pt
				)

					// For strings, we take the first n bytes of
					// the string and use that.

					mov( attrEBX.string_vt, edx );
					canAccess( [edx] );
					str.length( edx );
					if( eax > 16 ) then

						mov( 16, eax );

					endif;
					zeroAttr( [ebx] );		// Zero out data
					push( esi );
					push( edi );
					mov( edx, esi );
					lea( edi, attrEBX.uns8_vt );
					mov( eax, ecx );
					rep.movsb();
					pop( edi );
					pop( esi );

					// Free up storage used by string value:

					strfree( edx );

				default

					HLAerror
					( 
						"Cannot convert type ", 
						pTypeStrs[ eax*4 ], 
						" to numeric form" 
						nl 
					);
					exit error;					

			endswitch;
			clc();
			exit noerror;

		end error;
		mov( attr, ebx );
		freeAttr( [ebx] );
		raise( ex.hlaerr );

	end noerror;


end ctIntFunc;




////////////////////////////////////////////////////////////////////////////////
//
// ctInt128-
//
//	Handles the @Int128 function.

//proc( "ctInt128" )
procedure ctInt128( var attr:attr_t in ebx ); @noframe;
begin ctInt128;

	assert( attr <> NULL );
	ctIntFunc( attrEBX );
	mov( Int128_pt, attrEBX.pType );
	mov( &int128_ste, attrEBX.symType );
	ret();

end ctInt128;


// ctInt16-
//
//	Handles the @Int16 function.

//proc( "ctInt16" )
procedure ctInt16( var attr:attr_t in ebx ); @noframe;
begin ctInt16;

	assert( attr <> NULL );
	ctIntFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.word_vt, ax );
		zeroAttr( attrEBX );
		mov( ax, attrEBX.word_vt );
		mov( Int16_pt, attrEBX.pType );
		mov( &int16_ste, attrEBX.symType );

	endif;
	ret();

end ctInt16;


// ctInt32-
//
//	Handles the @Int32 function.

//proc( "ctInt32" )
procedure ctInt32( var attr:attr_t in ebx ); @noframe;
begin ctInt32;

	assert( attr <> NULL );
	ctIntFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.dword_vt, eax );
		zeroAttr( attrEBX );
		mov( eax, attrEBX.dword_vt );
		mov( Int32_pt, attrEBX.pType );
		mov( &int32_ste, attrEBX.symType );

	endif;
	ret();

end ctInt32;


// ctInt64-
//
//	Handles the @Int64 function.

//proc( "ctInt64" )
procedure ctInt64( var attr:attr_t in ebx ); @noframe;
begin ctInt64;

	assert( attr <> NULL );
	ctIntFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.dword_vt, eax );
		mov( attrEBX.dword_vt[4], ecx );
		zeroAttr( attrEBX );
		mov( eax, attrEBX.dword_vt );
		mov( ecx, attrEBX.dword_vt[4] );
		mov( Int64_pt, attrEBX.pType );
		mov( &int64_ste, attrEBX.symType );

	endif;
	ret();

end ctInt64;


// ctInt8-
//
//	Handles the @Int8 function.

//proc( "ctInt8" )
procedure ctInt8( var attr:attr_t in ebx ); @noframe;
begin ctInt8;

	assert( attr <> NULL );
	ctIntFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.byte_vt, al );
		zeroAttr( attrEBX );
		mov( al, attrEBX.byte_vt );
		mov( Int8_pt, attrEBX.pType );
		mov( &int8_ste, attrEBX.symType );

	endif;
	ret();

end ctInt8;




////////////////////////////////////////////////////////////////////////////////
//
// ctInto-
//
//	Handles the @Into function.

//proc( "ctInto" )
procedure ctInto( var attr:attr_t in ebx ); @noframe;
begin ctInto;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( doInto, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctInto;


////////////////////////////////////////////////////////////////////////////////
//
// ctIsAlpha-
//
//	Handles the @IsAlpha( chr ) function.

//proc( "ctIsAlpha" )
procedure ctIsAlpha( var attr:attr_t in ebx ); @noframe;
begin ctIsAlpha;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isAlpha expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		if( eax < $100 ) then

			bt( eax, {'A'..'Z', 'a'..'z'} );
			rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.

		endif;
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctIsAlpha;


// ctIsAlphaNum-
//
//	Handles the @IsAlphaNum function.

//proc( "ctIsAlphaNum" )
procedure ctIsAlphaNum( var attr:attr_t in ebx ); @noframe;
begin ctIsAlphaNum;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isAlphaNum expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		if( eax < $100 ) then

			bt( eax, {'A'..'Z', 'a'..'z', '0'..'9'} );
			rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.

		endif;
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctIsAlphaNum;


// ctIsClass-
//
//	Handles the @IsClass( identifier ) function.

//proc( "ctIsClass" )
procedure ctIsClass( var attr:attr_t in ebx ); @noframe;
begin ctIsClass;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// We only allow a single identifier as an argument
		// to the @isClass function:

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, ID_tc );
		pop( ebx );
		if( @ne ) then

			HLAerror( "@isClass expects an identifer as an argument" nl );
			exit error;

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol is undefined, else it is defined.

			if( eax != tkn_undefID ) then

				mov( tokenECX.symNode, eax );
				assert( eax <> NULL );
				cmp( symEAX.pType, Class_pt );
				mov( false, al );
				if( @e ) then

					mov( true, al );

				endif;

			else // It's undefined, it's not a class ID

				mov( false, al );

			endif;
			mov( al, attrEBX.boolean_vt );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mustMatchRParen();
			clc();
			ret();

		endif;

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctIsClass;


// ctIsConst-
//
//	Handles the @IsConst function.

//proc( "ctIsConst" )
procedure ctIsConst( var attr:attr_t );
begin ctIsConst;

	// Initialize the return value with all zeros:

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( attrEBX );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( false, attrEBX.boolean_vt );		// Assume it's not a constant

	// Parse a constant expression as the parameter for this function.

	matchLParen();
	raiseErr( @c );

	lex( esi );
	if( ebx = const_tc ) then

		// Okay, we've got a literal constant. Free the value
		// associated with it (which we don't use) and return
		// true as this function's result:

		freeTkn( tokenECX );
		mov( attr, ebx );
		canAccess( [ebx] );
		mov( true, attrEBX.boolean_vt );

	elseif( ebx = ID_tc ) then

		// We've got an identifier. If it's defined and it's
		// a constant identifier, then return true.

		if( eax <> tkn_undefID ) then // it must be defined

			mov( tokenECX.symNode, ebx );
			canAccess( [ebx] );
			mov( symEBX.symClass, al );
			if( al = Constant_ct || al = Value_ct ) then

				mov( attr, ebx );
				mov( true, attrEBX.boolean_vt );

			endif;

		endif;

	endif;
	mustMatchRParen();
end ctIsConst;


// ctIsDigit-
//
//	Handles the @IsDigit function.

//proc( "ctIsDigit" )
procedure ctIsDigit( var attr:attr_t in ebx ); @noframe;
begin ctIsDigit;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isDigit expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		bt( eax, {'0'..'9'} );
		rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctIsDigit;


// ctIsExpr-
//
//	Handles the @IsExpr function.
//
//	This function returns true/false depending upon whether it finds
// a valid constant expression passed to it.

//proc( "ctIsExpr" )
procedure ctIsExpr( var attr:attr_t );
var
	parenCnt	:uns32;
	constAttr	:attr_t;
	hadParen	:boolean;

	procedure getClosingParen; @noframe;
	begin getClosingParen;

		mov( false, ebp::hadParen );
		mov( 0, ebp::parenCnt );
		fastLex( esi );
		cmp( eax, ')' );
		sete( ebp::hadParen );
		forever

			if( eax = ')' ) then

				if( ebp::parenCnt = 0 ) then

					ret();

				endif;
				dec( ebp::parenCnt );

			elseif( eax = '(' ) then

				inc( ebp::parenCnt );

			endif;
			fastLex( esi );

		endfor;

	end getClosingParen;
begin ctIsExpr;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attr );
		mov( attr, ebx );
		canAccess( [ebx] );
		mov( false, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );

		// We only allow a single identifier as an argument
		// to the @isExternal function:

		matchLParen();
		exitif( @c ) error;

		// Call "testExpr" to see if the expression is valid

		testExpr( constAttr );
		if( constAttr.boolean_vt ) then

			// Look for a closing parenthesis:

			getClosingParen();
			mov( attr, ebx );
			canAccess( [ebx] );
			mov( false, attrEBX.boolean_vt );
			if( hadParen ) then

				// It was a valid constant expression (and attr is set
				// appropriately). Now let's check for the closing parenthesis:
				mov( true, attrEBX.boolean_vt );

			endif;
			clc();
			exit ctIsExpr;

		endif;

	end error;

	// If there was an error, scan until we get an unbalanced
	// closing parenthesis:

	getClosingParen();
	mov( attr, ebx );
	mov( false, attrEBX.boolean_vt );
	clc();
end ctIsExpr;


// ctIsExternal-
//
//	Handles the @IsExternal function.

//proc( "ctIsExternal" )
procedure ctIsExternal( var attr:attr_t in ebx ); @noframe;
begin ctIsExternal;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// We only allow a single identifier as an argument
		// to the @isExternal function:

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, ID_tc );
		pop( ebx );
		if( @ne ) then

			HLAerror( "@isExternal expects an identifer as an argument" nl );
			freeTkn( tokenECX );
			raise( ex.hlaerr );

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol is undefined, else it is defined.

			if( eax != tkn_undefID ) then

				mov( tokenECX.symNode, edx );
				canAccess( [edx] );
				mov( symEDX.isExternal, al );
				xor( symEDX.isPublic, al );	// just in case...

			else // It's undefined, it's not external.

				mov( false, al );

			endif;
			mov( al, attrEBX.boolean_vt );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mustMatchRParen();
			clc();
			ret();

		endif;

	end error;
	raise( ex.hlaerr );
end ctIsExternal;


// ctIsLower-
//
//	Handles the @IsLower function.

//proc( "ctIsLower" )
procedure ctIsLower( var attr:attr_t in ebx ); @noframe;
begin ctIsLower;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isLower expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		bt( eax, {'a'..'z'} );
		rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsLower;


// ctIsMem-
//
//	Handles the @IsMem function.

//proc( "ctIsMem" )
procedure ctIsMem( var attr:attr_t );
var
	parenCnt	:uns32;
	constAttr	:attr_t;
begin ctIsMem;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attr );

		// We only allow a single identifier as an argument
		// to the @isExternal function:

		matchLParen();
		exitif( @c ) error;

		// Call "testMemory" to see if the memory expression is valid

		testMemory( attr );
		if( @nc ) then

			// It was a valid memory expression (and attr is set
			// appropriately). Now let's check for the closing parenthesis:
			mustMatchRParen();
			clc();
			exit ctIsMem;

		endif;

	end error;

	// If there was an error, scan until we get an unbalanced
	// closing parenthesis:

	mov( 0, parenCnt );
	forever

		lex( esi );
		if( eax = ')' ) then

			breakif( parenCnt = 0 );
			dec( parenCnt );

		elseif( eax = '(' ) then

			inc( parenCnt );

		endif;

	endfor;
	raise( ex.hlaerr );

end ctIsMem;


// ctIsReg-
//
//	Handles the @IsReg function.
// Returns true if the token passed as an argument is an integer register.

//proc( "ctIsReg" )
procedure ctIsReg( var attr:attr_t in ebx ); @noframe;
begin ctIsReg;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, reg8_tc );
		pushd( false );
		if( @ae ) then

			// If the token we just saw was an integer register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctIsReg;


// ctIsReg16-
//
//	Handles the @IsReg16 function.

//proc( "ctIsReg16" )
procedure ctIsReg16( var attr:attr_t in ebx ); @noframe;
begin ctIsReg16;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, reg16_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was a 16-bit integer register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsReg16;


// ctIsReg32-
//
//	Handles the @IsReg32 function.

//proc( "ctIsReg32" )
procedure ctIsReg32( var attr:attr_t in ebx ); @noframe;
begin ctIsReg32;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, reg32_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was a 32-bit integer register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsReg32;


// ctIsReg8-
//
//	Handles the @isReg8 function.

//proc( "isReg8" )
procedure isReg8( var attr:attr_t in ebx ); @noframe;
begin isReg8;

	canAccess( [ebx] );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );

		cmp( ebx, reg8_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was an 8-bit integer register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end isReg8;


// ctIsRegFPU-
//
//	Handles the @IsRegFPU function.

//proc( "ctIsRegFPU" )
procedure ctIsRegFPU( var attr:attr_t in ebx ); @noframe;
begin ctIsRegFPU;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, regfpu_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was an FPU register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsRegFPU;


// ctIsRegMMX-
//
//	Handles the @ctIsRegMMX function.

//proc( "ctIsRegMMX" )
procedure ctIsRegMMX( var attr:attr_t in ebx ); @noframe;
begin ctIsRegMMX;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, regmmx_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was an MMX register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsRegMMX;


// ctIsRegSSE-
//
//	Handles the @isRegSSE function.

//proc( "ctIsRegSSE" )
procedure ctIsRegSSE( var attr:attr_t in ebx ); @noframe;
begin ctIsRegSSE;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, regsse_tc );
		pushd( false );
		if( @e ) then

			// If the token we just saw was an SSE register,
			// then replace the false on TOS with true:

			mov( true, (type dword [esp]) );

		else

			// If it wasn't a register, free the token as there
			// might be heap memory associated with the token.

			freeTkn( [ecx] );


		endif;

		// Make sure whatever follows is a right parenthesis.
		// Note that EAX still contains the token value from
		// the previous call to lex. We need to reuse it if
		// it is either '(' or ')'.

		if( eax = '(' || eax = ')' ) then

			reuseLastTkn();

		endif;
		getRightParen();
		and( [esp], eax );
		add( 4, esp );
		pop( ebx );
		mov( al, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsRegSSE;


// ctIsSpace-
//
//	Handles the @ctIsSpace function.

//proc( "ctIsSpace" )
procedure ctIsSpace( var attr:attr_t in ebx ); @noframe;
begin ctIsSpace;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isSpace expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		bt( eax, {stdio.tab, ' ', stdio.cr, stdio.lf} );
		rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );

end ctIsSpace;


// ctIsType-
//
//	Handles the @IsType function.

//proc( "ctIsType" )
procedure ctIsType( var attr:attr_t in ebx ); @noframe;
begin ctIsType;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// We only allow a single identifier as an argument
		// to the @isType function:

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );

		// Free any allocated storage associated with
		// this token, we won't need it.

		freeTkn( [ecx] );

		cmp( eax, tkn_undefID );	// Not type ID if undefined
		je NotTypeID;

		cmp( ebx, type_tc );		// Is a type ID if a type rsvd word
		je IsTypeRW;

		cmp( ebx, ID_tc );			// Else if not an ID, it can't
		jne NotTypeID;				// be a type ID.

		mov( tokenECX.symNode, ebx );
		canAccess( [ebx] );
		cmp( symEBX.symClass, Type_ct );	// See if it's a class ID
		jne NotTypeID;

		IsTypeRW:

			// If we get to this point, it is a type ID or reserved word.

			pop( ebx );
			canAccess( [ebx] );
			mov( true, attrEBX.boolean_vt );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );

			// Must have a closing right parenthesis at this point,
			// else we've got to return false.

			push( ebx );
			lex( esi );
			if( eax = ')' ) then

				pop( ebx );
				clc();
				ret();

			endif;


		// If it wasn't a type identifier, eat everything up to the
		// closing parenthesis and return false:

		NotTypeID:

			pop( ebx );		// Retrieve attr pointer

			// Who knows what we've got?
			if( eax = '(' || eax = ')' ) then

				reuseLastTkn();

			endif;
			getRightParen();

			// Return false, as this is not a type ID:

			zeroAttr( attrEBX );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			clc();
			ret();

	end error;
	raise( ex.hlaerr );
end ctIsType;


// ctIsUpper-
//
//	Handles the @IsUpper function.

//proc( "ctIsUpper" )
procedure ctIsUpper( var attr:attr_t in ebx ); @noframe;
begin ctIsUpper;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isUpper expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		bt( eax, {'A'..'Z'} );
		rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsUpper;


// ctIsXDigit-
//
//	Handles the @IsXDigit function.

//proc( "ctIsXDigit" )
procedure ctIsXDigit( var attr:attr_t in ebx ); @noframe;
begin ctIsXDigit;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( al != Char_pt && al != Unicode_pt ) then
		
			HLAerror
			( 
				"@isXDigit expected a character argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a character operand. Now see if it is an
		// alphabetic character.

		movzx( attrEBX.word_vt, eax );
		zeroAttr( attrEBX );
		bt( eax, {'A'..'F', 'a'..'f', '0'..'9'} );
		rcl( 1, attrEBX.boolean_vt );		// Sets true/false based on bt.
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	raise( ex.hlaerr );
end ctIsXDigit;


// ctLastObject-
//
//	Handles the @LastObject function.

//proc( "ctLastObject" )
procedure ctLastObject( var attr:attr_t in ebx ); @noframe;
begin ctLastObject;

	//#print( "TODO: ctLastObject function" );
	HLAerror( "@lastObject is not supported in HLA v2.0" nl );
	raise( ex.hlaerr );
	ret();

end ctLastObject;


// ctLeave-
//
//	Handles the @Leave function.

//proc( "ctLeave" )
procedure ctLeave( var attr:attr_t in ebx ); @noframe;
begin ctLeave;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultLeave, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctLeave;


// ctLength-
//
//	Handles the @Length function.

//proc( "ctLength" )
procedure ctLength( var attr:attr_t ); 
	@nodisplay; 
	@nostackalign;

var
	strExpr	: attr_t;

begin ctLength;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.length function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			if( strExpr.pType = Utf8_pt ) then

				utf8Len( strExpr.string_vt );

			else
				str.length( strExpr.string_vt );
				if( strExpr.pType = UString_pt ) then

					shr( 1, eax );

				endif;

			endif;
			mov( eax, attrEBX.uns32_vt );
			mov( Uns32_pt, attrEBX.pType );
			mov( &uns32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;
	freeAttr( strExpr );
	clc();

end ctLength;


// ctLex-
//
//	Handles the @Lex function.

//proc( "ctLex" )
procedure ctLex( var attr:attr_t in ebx ); @noframe;
begin ctLex;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Int32_pt, attrEBX.pType );
	mov( &int32_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( curLexLevel, eax );
	mov( eax, attrEBX.dword_vt );
	cdq();
	mov( edx, attrEBX.dword_vt[4] );
	mov( edx, attrEBX.dword_vt[8] );
	mov( edx, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctLex;


// ctLineNumber-
//
//	Handles the @LineNumber function.

//proc( "ctLineNumber" )
procedure ctLineNumber( var attr:attr_t in ebx ); @noframe;
begin ctLineNumber;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( lineNumber, eax );
	mov( eax, attrEBX.dword_vt );
	clc();
	ret();

end ctLineNumber;


// ctLocalOffset-
//
//	Handles the @LocalOffset function.
//	This returns the current value of the startLclOffs variable.

//proc( "ctLocalOffset" )
procedure ctLocalOffset( var attr:attr_t in ebx ); @noframe;
begin ctLocalOffset;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( startLclOffs, eax );
	mov( eax, attrEBX.dword_vt );
	clc();
	ret();

end ctLocalOffset;


// ctLocalSyms-
//
//	Handles the @LocalSyms function.

//proc( "ctLocalSyms" )
procedure ctLocalSyms( var attr:attr_t );
var
	strArrayType	:string;
	dummy			:symNodePtr_t;
	linearSyms		:symNodePtr_t;

readonly
	localsArrayStr :string := "@localsymtemp";

begin ctLocalSyms;

	str.talloc(32);
	mov( eax, strArrayType );
	assert( attr <> NULL );
	
	// Initialize the return value with all zeros:

	defaultAttr( attr );

	begin error;

		// We only allow a single identifier as an argument
		// to the @localSyms function:

		matchLParen();
		exitif( @c ) error;

		getTypeOfID();
		if( @c ) then

			HLAerror
			( 
				"@localSyms expects a defined identifer with a type "
				"as an argument" nl 
			);
			exit error;

		endif;

		// If the "alloc" flag is true, then we need to
		// deallocate the storage assocated with the
		// identifier:

		if( tokenECX.alloc ) then

			strfree( tokenECX.trueName );
			strfree( tokenECX.lcName );

		endif;

		// Determine if this is a symbol that has a local
		// symbol table:

		canAccess( [ebx] );
		mov( symEBX.pType, al );
		if
		(
				al = Record_pt
			||	al = Union_pt
			||	al = Class_pt
			||	al = Namespace_pt
			||	al = Symboltbl_pt
			||	al = Segment_pt
			||	al = Proc_pt
			||	al = Method_pt
			||	al = ClassProc_pt
			||	al = ClassIter_pt
			||	al = Iterator_pt
			||	al = Program_pt
		) then

			// Count the number of symbols in the local
			// symbol table (into EDX):

			mov( symEBX.linearSyms, ecx );
			xor( edx, edx );
			mov( ecx, linearSyms );
			while( ecx <> NULL ) do

				if( symECX.pType <> Placeholder_pt ) then

					inc( edx );

				endif;
				mov( symECX.next, ecx );

			endwhile;

			// Create a dummy symbol table entry to hold
			// the strings with the local names. We're not really
			// going to enter this into the symbol table,
			// but we need it for the following constant.
			// Too bad, the memory for this is never recovered
			// (i.e., this is a memory leak). Fortunately, the
			// @localSyms function doesn't get called very often, so
			// this is no big deal.

			str.put( strArrayType, "@string[", (type uns32 edx), ']' );
			str.a_cpy( strArrayType );
			mov( eax, ecx );

			malloc( @size( symNode_t ));
			mov( eax, dummy );

			mov( ecx, symEAX.trueName );
			mov( ecx, symEAX.lcName );
			mov( &string_ste, symEAX.baseType );
			mov( Array_pt, symEAX.pType );
			mov( Type_ct, symEAX.symClass );
			mov( curHashTable, ecx );
			mov( hashECX.owner, ecx );
			mov( ecx, symEAX.owner );
			mov( curLexLevel, symEAX.lexLevel );
			lea( ecx, [edx*4] );
			mov( ecx, symEAX.objectSize );
			mov( false, symEAX.isExternal );
			mov( false, symEAX.isPublic );
			mov( false, symEAX.isReferenced );
			mov( false, symEAX.isForward );
			mov( false, symEAX.isPrivate );
			mov( false, symEAX.isReadOnly );
			mov( notp_pc, symEAX.pClass );
			mov( _none, symEAX.inReg );
			mov( NULL, symEAX.externName );
			mov( 0, symEAX.offset );
			mov( edx, symEAX.numElements );

			// Okay, create an array of attr_t objects to
			// hold the local symbols:

			intmul( @size( attr_t ), edx, eax );
			malloc( eax );

			// Initialize the attr object to be an array of
			// string values:

			mov( attr, ecx );
			canAccess( [ecx] );
			mov( dummy, attrECX.symType );
			mov( Deferred_pt, attrECX.pType );
			mov( Constant_ct, attrECX.symClass );
			mov( eax, attrECX.arrayValues_vt );
			mov( edx, attrECX.numElements );

			// Okay, set the values for each of these attr objects
			// to the names of all the local symbols:

			mov( linearSyms, edx );
			mov( attrECX.arrayValues_vt, ebx );
			while( edx <> NULL ) do

				if( symEDX.pType <> Placeholder_pt ) then

					str.a_cpy( symEDX.trueName );
					mov( eax, attrEBX.string_vt );
					mov( 0, attrEBX.numElements );
					mov( &string_ste, attrEBX.symType );
					mov( String_pt, attrEBX.pType );
					mov( Constant_ct, attrEBX.symClass );

					add( @size( attr_t ), ebx );

				endif;
				mov( symEDX.next, edx );

			endwhile;
			mustMatchRParen();
			clc();
			exit ctLocalSyms;

		endif;

		// If it's not a symbol that has a local symbol table
		// associated with it, then just return an empty string
		// as this function's value:

		mov( attr, ebx );
		canAccess( [ebx] );
		str.a_cpy( "" );
		mov( eax, attrEBX.string_vt );
		mov( 0, attrEBX.numElements );
		mov( &string_ste, attrEBX.symType );
		mov( String_pt, attrEBX.pType );
		mov( Constant_ct, attrEBX.symClass );
		mustMatchRParen();
		clc();
		exit ctLocalSyms;
	end error;

	// Error, so eat everything up to the closing right parenthesis:
	getRightParen();

	// Return a reasonable result to the caller:
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctLocalSyms;


// ctLog-
//
//	Handles the @Log function (Base-e logarithm).

//proc( "ctLog" )
procedure ctLog( var attr:attr_t in ebx ); @noframe;
begin ctLog;

	canAccess( [ebx] );
	finit();
	fclex();
	matchLParen();
	jc badLog;
	constExpr( attrEBX );
	mustMatchRParen();
	makeReal80( attrEBX );
	math.ln();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	clc();	
	ret();

badLog:
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctLog;


// ctLog10-
//
//	Handles the @Log10 function (Base-10 logarithm).

//proc( "ctLog10" )
procedure ctLog10( var attr:attr_t in ebx ); @noframe;
begin ctLog10;

	canAccess( [ebx] );
	finit();
	fclex();
	matchLParen();
	jc badLog;
	constExpr( [ebx] );
	mustMatchRParen();
	makeReal80( attrEBX );
	math.log();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );
	clc();	
	ret();

badLog:
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctLog10;


// ctLowercase-
//
//	Handles the @Lowercase function.

//proc( "ctLowercase" )
procedure ctLowercase( var attr:attr_t in ebx ); @noframe;
begin ctLowercase;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		//defaultAttr( attr );
		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		switch( eax )

			case( Char_pt )

				// Okay, it was a character operand. Convert it to
				// lower case (if necessary).

				mov( attrEBX.char_vt, al );
				chars.toLower( al );
				mov( al, attrEBX.char_vt );
				clc();
				ret();

			case( Unicode_pt )

				// Okay, it was a unicode operand. Convert it to
				// lower case (if necessary).

				mov( attrEBX.word_vt, ax );
				if( ax in word('A')..word('Z')) then

					chars.toLower( al );
					mov( al, attrEBX.char_vt );

				endif;
				clc();
				ret();

			case( String_pt, Utf8_pt )

				// Okay, it was a string operand. Convert it to
				// lower case (if necessary).

				str.lower( attrEBX.string_vt );
				clc();
				ret();

			case( UString_pt );

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( ecx <> 0 ) then

					repeat

						mov( [edx], ax );
						if( ax in word('A')..word('Z')) then

							chars.toLower( al );
							mov( al, [edx] );

						endif;
						add( 2, edx );
						sub( 2, ecx );

					until( @z );

				endif;
				clc();
				ret();


			default
				HLAerror
				( 
					"@lowercase expected a character or string argument, " nl
					"but encountered a ", 
					pTypeStrs[ eax*4 ], 
					" argument" 
					nl 
				);
				exit error;

		endswitch;
		clc();
		ret();

	end error;
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctLowercase;


// ctLword-
//
//	Handles the @Lword function.

//proc( "ctLword" )
procedure ctLword( var attr:attr_t ); 
var
	index		:dword;
	whichLWord	:attr_t;

begin ctLword;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );
			exitif( @c ) error;

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@lword function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first lword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichLWord );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichLWord.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @lword must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichLWord.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichLWord.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichLWord.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @lword"
						nl
					);
					exit error;

				endif;
				mov( whichLWord.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @lword, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if
				( 
						eax >= symEDX.objectSize
					&&	!isNumber( symEDX.pType ) 
				) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as second @lword argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an LWORD object,
				// we only need to transfer 16 bytes, so compute
				// the minimum of objectsize-index and 16 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 16 ) then

					mov( 16, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the LWORD,
				// if the original data type (plus the index) had
				// fewer than 16 bytes:

				while( edx < 16 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the LWORD:

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );


			else // We've got a string, UTF-8 string, or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( eax >= ecx ) then

					HLAerror
					(
						"Second argument to @lword indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 16 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 16 ) then

					mov( 16, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the LWORD,
				// if the original data type (plus the index) had
				// fewer than 16 bytes:

				while( esi < 16 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( LWord_pt, attrEBX.pType );
			mov( &lword_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctLword;


// ctMatchID-
//
//	Handles the @MatchID function.
//	@MatchID( string, {optionalRemainder}, {optionalMatched} );
//  This function returns true if "string" matches an identifier. 

//proc( "ctMatchID" )
procedure ctMatchID( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchID;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second @MatchID argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@MatchID argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchID - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match an identifier:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				// First char must be alpha or "_":

				movzx( (type char [edx]), eax );
				bt( eax, {'_', 'A'..'Z', 'a'..'z'} );
				exitif( @nc ) rtnFalse;

				// Match up to a character that is not alphanumeric or "_":

				mov( 1, ecx );
				forever

					movzx( (type char [edx+ecx]), eax );
					bt( eax, {'_', 'A'..'Z', 'a'..'z', '0'..'9'} );
					breakif( @nc );
					inc( ecx );

				endfor;

				// We'll, we've matched an identifier.
				
				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly an identifier. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchID;


// ctMatchIntConst-
//
//	Handles the @MatchIntConst function.
//	@MatchIntConst( string, {optionalRemainder}, {optionalMatched} );
//  This function returns true if "string" matches a literal integer constant.
//	Note that we allow interior underscores, but we don't match the underscores
//	appearing at the end of the sting. 

//proc( "ctMatchIntConst" )
procedure ctMatchIntConst( var attr:attr_t);
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchIntConst;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@MatchIntConst argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@MatchIntConst argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchIntConst - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match a literal integer constant:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );

				// Match up to a character that is not numeric or "_":

				mov( 0, ecx );
				exitif( (type char [edx]) < '0' ) rtnFalse;
				exitif( (type char [edx]) > '9' ) rtnFalse;
				whileIsDigit:
					mov( ecx, eax );	// Save position of last digit
				whileIsUnderscore:
					inc( ecx );

					cmp( (type char [edx+ecx]), '_' );
					je whileIsUnderscore;
					cmp( (type char [edx+ecx]), '0' );
					jb NotADigit;
					cmp( (type char [edx+ecx]), '9' );
					jbe whileIsDigit;
					

				NotADigit:
					lea( ecx, [eax+1] );	// Length of string of digits.

				// We'll, we've matched an integer constant.
				
				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;

				// Unlike most matching functions, we return an integer
				// value for "matched" rather than a string.

				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &uns32_ste, symEDX.symType );
					mov( Uns32_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					push( eax );	// Save for strfree later.
					conv.strTou32( eax, 0 );
					mov( eax, symEDX.va.uns32_vt );
					call( strfree );	// parameter is already on the stack.

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly an identifier. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to zero.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				mov( &uns32_ste, symEDX.symType );
				mov( Uns32_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );
				xor( eax, eax );
				mov( eax, symEDX.va.uns32_vt );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchIntConst;


// ctMatchIStr-
//
//	Handles the @MatchIStr function.
//  @MatchIStr( string, matchToStr, {optional_Remainder}, {optional_match} );

//proc( "ctMatchIStr" )
procedure ctMatchIStr( var attr:attr_t );
var
	theString		:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchIStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theString );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( theString );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @MatchIStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@MatchIStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchIStr - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match the characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.iprefix( attrEBX.string_vt, theString.string_vt );
				exitif( !al ) rtnFalse;
								
				// We'll, we've matched all the characters.
				
				// Okay, we've matched the prefix string.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					mov( attrEBX.string_vt, edx );
					canAccess( [edx] );
					mov( (type str.strRec [edx]).length, edx );
					mov( theString.string_vt, eax );
					mov( (type str.strRec [eax]).length, eax );
					sub( eax, edx );
					str.a_substr( attrEBX.string_vt, eax, edx );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					mov( theString.string_vt, eax );
					mov( (type str.strRec [eax]).length, eax );
					str.a_substr( attrEBX.string_vt, 0, eax );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the prefix string. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchIStr;


// ctMatchNumConst-
//
//	Handles the @MatchNumConst function.
//  This is a combination of @MatchIntConst and @MatchRealConst.
//	It will match either type of string.

//proc( "ctMatchNumConst" )
procedure ctMatchNumConst( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;
	matchedReal		:boolean;

begin ctMatchNumConst;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	mov( false, matchedReal );
	begin noerror;

		begin error;

			// Get the values from the source file "(string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@MatchIntConst argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@MatchIntConst argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchIntConst - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match a literal integer constant:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );

				// Match up to a character that is not numeric or "_":

				mov( 0, ecx );

				// Real numbers may begin with an optional "-":

				if( (type char [edx]) = '-' ) then

					inc( ecx );
					mov( true, matchedReal );

				endif;
				exitif( (type char [edx+ecx]) < '0' ) rtnFalse;
				exitif( (type char [edx+ecx]) > '9' ) rtnFalse;

				// Match something that looks like an integer:

				whileIsDigit:
					mov( ecx, eax );	// Save position of last digit
				whileIsUnderscore:
					inc( ecx );

					cmp( (type char [edx+ecx]), '_' );
					je whileIsUnderscore;
					cmp( (type char [edx+ecx]), '0' );
					jb NotADigit;
					cmp( (type char [edx+ecx]), '9' );
					jbe whileIsDigit;
					

				NotADigit:
					lea( ecx, [eax+1] );	// Length of string of digits.

				// Now check to see if we've got a real constant. The two
				// things that being a real constant are "." or "e"/"E":

				if( (type char [edx+ecx]) = '.' ) then

					mov( true, matchedReal );
					whileIsFraction:
						mov( ecx, eax );	// Save position of last digit
					whileIsUnderscore2:
						inc( ecx );

						cmp( (type char [edx+ecx]), '_' );
						je whileIsUnderscore2;
						cmp( (type char [edx+ecx]), '0' );
						jb NotAFraction;
						cmp( (type char [edx+ecx]), '9' );
						jbe whileIsFraction;

					NotAFraction:
						lea( ecx, [eax+1] );	// Length of string of digits.

				endif;

				// Check for an exponent here:

				mov( [edx+ecx], al );
				and( $5f, al );  //lc->UC conversion
				if( al = 'E' ) then

					mov( true, matchedReal );
					inc( ecx );

					// Allow a sign after the "e"/"E":

					if
					( 
							(type char [edx+ecx]) = '-' 
						||	(type char [edx+ecx]) = '+'
					) then

						inc( ecx );

					endif;

					// Must have at least one digit after the "e"/"E":

					exitif( (type char [edx+ecx]) < '0' ) rtnFalse;
					exitif( (type char [edx+ecx]) > '9' ) rtnFalse;

					whileIsExponent:
						mov( ecx, eax );	// Save position of last digit
					whileIsExpDigit:
						inc( ecx );
						cmp( (type char [edx+ecx]), '0' );
						jb NotAnExponent;
						cmp( (type char [edx+ecx]), '9' );
						jbe whileIsExpDigit;

					NotAnExponent:
						lea( ecx, [eax+1] );	// Length of string of digits.

				endif;

				// We'll, we've matched a numeric constant.
				
				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;

				// Unlike most matching functions, we return an integer
				// value for "matched" rather than a string.

				if( hasMatched ) then

					if( matchedReal ) then

						mov( matchedSym, edx );
						canAccess( [edx] );
						mov( &real80_ste, symEDX.symType );
						mov( Real80_pt, symEDX.pType );
						mov( 10, symEDX.objectSize );
						str.a_substr( attrEBX.string_vt, 0, ecx );
						push( eax );	// Save ptr to string.
						conv.strToFlt( eax, 0 );
						fstp( symEDX.va.real80_vt );
					
					else

						mov( matchedSym, edx );
						canAccess( [edx] );
						mov( &uns32_ste, symEDX.symType );
						mov( Uns32_pt, symEDX.pType );
						mov( 4, symEDX.objectSize );
						str.a_substr( attrEBX.string_vt, 0, ecx );
						push( eax );	// Save for strfree later.
						conv.strTou32( eax, 0 );
						mov( eax, symEDX.va.uns32_vt );
					
					endif;

					// Tricky code, the strfree parameter was
					// pushed on the stack by the two halves of
					// the if statement above.
					
					call( strfree ); // Free string data.

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly an identifier. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to zero.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				mov( &uns32_ste, symEDX.symType );
				mov( Uns32_pt, symEDX.pType );
				mov( 4, symEDX.objectSize );
				xor( eax, eax );
				mov( eax, symEDX.va.uns32_vt );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchNumConst;


// ctMatchRealConst-
//
//	Handles the @MatchRealConst function.

//proc( "ctMatchRealConst" )
procedure ctMatchRealConst( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchRealConst;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@MatchRealConst argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@MatchRealConst argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchRealConst - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match a literal integer constant:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );

				// Match up to a character that is not numeric or "_":

				mov( 0, ecx );

				// Real numbers may begin with an optional "-":

				if( (type char [edx]) = '-' ) then

					inc( ecx );

				endif;
				exitif( (type char [edx+ecx]) < '0' ) rtnFalse;
				exitif( (type char [edx+ecx]) > '9' ) rtnFalse;

				// Match something that looks like an integer:

				whileIsDigit:
					mov( ecx, eax );	// Save position of last digit
				whileIsUnderscore:
					inc( ecx );

					cmp( (type char [edx+ecx]), '_' );
					je whileIsUnderscore;
					cmp( (type char [edx+ecx]), '0' );
					jb NotADigit;
					cmp( (type char [edx+ecx]), '9' );
					jbe whileIsDigit;
					

				NotADigit:
					lea( ecx, [eax+1] );	// Length of string of digits.

				// Now check to see if we've got a real constant. The two
				// things that being a real constant are "." or "e"/"E":

				if( (type char [edx+ecx]) = '.' ) then

					whileIsFraction:
						mov( ecx, eax );	// Save position of last digit
					whileIsUnderscore2:
						inc( ecx );

						cmp( (type char [edx+ecx]), '_' );
						je whileIsUnderscore2;
						cmp( (type char [edx+ecx]), '0' );
						jb NotAFraction;
						cmp( (type char [edx+ecx]), '9' );
						jbe whileIsFraction;

					NotAFraction:
						lea( ecx, [eax+1] );	// Length of string of digits.

				endif;

				// Check for an exponent here:

				mov( [edx+ecx], al );
				and( $5f, al );  //lc->UC conversion
				if( al = 'E' ) then

					inc( ecx );

					// Allow a sign after the "e"/"E":

					if
					( 
							(type char [edx+ecx]) = '-' 
						||	(type char [edx+ecx]) = '+'
					) then

						inc( ecx );

					endif;

					// Must have at least one digit after the "e"/"E":

					exitif( (type char [edx+ecx]) < '0' ) rtnFalse;
					exitif( (type char [edx+ecx]) > '9' ) rtnFalse;

					whileIsExponent:
						mov( ecx, eax );	// Save position of last digit
					whileIsUnderscore3:
						inc( ecx );

						cmp( (type char [edx+ecx]), '0' );
						jb NotAnExponent;
						cmp( (type char [edx+ecx]), '9' );
						jbe whileIsExponent;

					NotAnExponent:
						lea( ecx, [eax+1] );	// Length of string of digits.

				endif;

				// We'll, we've matched a numeric constant.
				
				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;

				// Unlike most matching functions, we return an integer
				// value for "matched" rather than a string.

				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &real80_ste, symEDX.symType );
					mov( Real80_pt, symEDX.pType );
					mov( 10, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					canAccess( [eax] );
					conv.strToFlt( eax, 0 );
					fstp( symEDX.va.real80_vt );
					
					canAccess( [eax] );
					strfree( eax );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly an identifier. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to zero.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, edx );
				canAccess( [edx] );
				mov( &real80_ste, symEDX.symType );
				mov( Real80_pt, symEDX.pType );
				mov( 10, symEDX.objectSize );
				fldz();
				fstp( symEDX.va.real80_vt );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctMatchRealConst;




// ctMatchStr-
//
//	Handles the @MatchStr function.
//	@MatchStr( string, prefix, {optional_remainder}, {optional_matched} );

//proc( "ctMatchStr" )
procedure ctMatchStr( var attr:attr_t ); 
var
	theString		:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theString );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( theString );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @MatchStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@MatchStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchStr - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match the characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.prefix( attrEBX.string_vt, theString.string_vt );
				exitif( !al ) rtnFalse;
								
				// We'll, we've matched all the characters.
				
				// Okay, we've matched the prefix string.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					mov( attrEBX.string_vt, edx );
					mov( (type str.strRec [edx]).length, edx );
					mov( theString.string_vt, eax );
					mov( (type str.strRec [eax]).length, eax );
					sub( eax, edx );
					str.a_substr( attrEBX.string_vt, eax, edx );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					mov( theString.string_vt, eax );
					mov( (type str.strRec [eax]).length, eax );
					str.a_substr( attrEBX.string_vt, 0, eax );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the prefix string. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchStr;


// ctMatchStrConst-
//
//	Handles the @MatchStrConst function.
//
// @MatchStrConst( String, Remainder, Matched )

//
// This function matches an HLA-compatible literal string constant.
// This includes embedded quotes (which are doubled up) and also
// juxtaposed string constants separated by nothing more than
// whitespace.

//proc( "ctMatchStrConst" )
procedure ctMatchStrConst( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	strSym			:symNodePtr_t;
	strExpr			:tokenPtr_t;
	startOfMatched	:dword;
	startOfRemainder:dword;
	hasRemainder	:boolean;
	hasMatched		:boolean;
	hasStr			:boolean;
	gotAStr			:boolean;

begin ctMatchStrConst;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	mov( false, hasStr );
	begin noerror;

		begin error;

			// Get the value from the source file "( string )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@MatchStrConst argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@MatchStrConst argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );
					if( eax = ',' ) then

						lex( esi );
						if( ebx <> ID_tc ) then

							HLAerror
							( 
								"Expected an identifier as fourth "
								"@MatchStrConst argument" 
								nl 
							);
							exit error;

						endif;
						checkValID( [ecx] );
						exitif( @c ) error;
						mov( tokenECX.symNode, eax );
						mov( eax, strSym );
						mov( true, hasStr );

						// Need to scan for the next token
						// because the following code expects
						// the token to be sitting in EAX:

						lex( esi );

					endif;


				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @MatchStrConst - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, 
				// let's see if we can match a string constant:
				//
				// We're going to cheat and use the lexer to
				// match a string constant for us:

				push( esi );
				push( edi );
				push( EOF );

				// Set lexer pointers to point at our string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, esi );
				canAccess( [esi] );
				mov( esi, edi );
				mov( (type str.strRec [esi]).length, eax );
				add( esi, eax );
				mov( eax, EOF );


				// Use the lexer to process the data in the string:

				lex( esi );
				mov( edi, startOfMatched );

				// If it wasn't a string constant, then restore
				// lexer stuff and return false.

				if( eax <> tkn_strConst && eax <> tkn_charConst ) then

					freeTkn( [ecx] );
					pop( EOF );
					pop( edi );
					pop( esi );
					exit rtnFalse;

				endif;

				// Create the full string constant

				mov( ecx, strExpr );
				mov( false, gotAStr );
				try
					getStrConst( (type token_t [ecx]).attr );
					mov( true, gotAStr );

				  exception( ex.hlaerr );
					// Note: by default, we assume an error (gotAStr).
				  
				endtry;

				// If we didn't get a real string, then return false:

				if( !gotAStr ) then

					freeTkn( [ecx] );
					pop( EOF );
					pop( edi );
					pop( esi );
					exit rtnFalse;

				endif;
				 
				// Okay, we got a string constant.
				// Don't include whitespace in matched string:

				mov( attr, ebx );
				canAccess( [ebx] );
				while
				( 
						edi > attrEBX.string_vt 
					&&	(type char [edi-1]) <= ' '
				) do

					dec( edi );

				endwhile;
				mov( edi, startOfRemainder );
				lex( esi );	// Clean up when done.

				// Lexer told us that we've got a string constant.

				if( hasRemainder ) then
				
					// ESI points at the first character beyond the
					// string that we matched. This is a zero-terminated
					// string so convert it to an HLA string and use
					// it as our remainder string:
					
					mov( startOfRemainder, eax );
					canAccess( [eax] );
					str.a_cpyz( eax );

					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( eax, symEDX.va.string_vt );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );

				endif;

				if( hasMatched ) then

					// The characters in the range startOfMatched..
					// StartOfRemainder are the string we matched. 
					// Convert these to a string and return them as 
					// the matched string.

					push( ecx );
					mov( startOfRemainder, ecx );
					sub( startOfMatched, ecx );	// Compute length.
					stralloc( ecx );			// Create storage for string
					mov( ecx, (type str.strRec [eax]).length );
					mov( startOfMatched, esi );
					mov( eax, edi );
					rep.movsb();
					mov( 0, (type byte [edi]) );

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					mov( eax, symEDX.va.string_vt );
					pop( ecx );

				endif;

				if( hasStr ) then

					// Return the string value that the lexer
					// returned to us.
					
					mov( strExpr, ecx );
					canAccess( [ecx] );
					str.a_cpy( tokenECX.attr.string_vt );
					mov( strSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeTkn( strExpr );
				mov( attr, ebx );
				canAccess( [ebx] );
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				pop( EOF );
				pop( edi );
				pop( esi );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the prefix string. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			mov( attr, ebx );
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctMatchStrConst;


// ctMatchToIStr-
//
//	Handles the @ctMatchToIStr function.
//
//	@MatchToIStr( string, tomatch{, remainder{, matched}} )
//
// Matches all the characters upto, but not including, the tomatch string.

//proc( "ctMatchToIStr" )
procedure ctMatchToIStr( var attr:attr_t );
var
	theString		:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchToIStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theString );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( theString );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @MatchToIStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@MatchToIStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchToIStr - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can find the substring:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.iindex( attrEBX.string_vt, theString.string_vt );
				exitif( eax = -1 ) rtnFalse;
								
				// We'll, we've found the substring.  EAX is the index
				// to the start of the string.
				
				if( hasRemainder ) then
				
					push( eax );
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					mov( attrEBX.string_vt, edx );
					canAccess( [edx] );
					mov( (type str.strRec [edx]).length, edx );
					sub( eax, edx );
					str.a_substr( attrEBX.string_vt, eax, edx );
					mov( eax, symECX.va.string_vt );
					pop( eax );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					str.a_substr( attrEBX.string_vt, 0, eax );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the prefix string. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		freeAttr( theString );
		raise( ex.hlaerr );

	end noerror;

end ctMatchToIStr;


// ctMatchToStr-
//
//	Handles the @MatchToStr function.

//proc( "ctMatchToStr" )
procedure ctMatchToStr( var attr:attr_t );
var
	theString		:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctMatchToStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theString );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, string)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( theString );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @MatchToStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );

				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@MatchToStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @MatchToStr - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can find the substring:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.index2( attrEBX.string_vt, theString.string_vt );
				exitif( eax = -1 ) rtnFalse;
								
				// We'll, we've found the substring.  EAX is the index
				// to the start of the string.
				
				if( hasRemainder ) then
				
					push( eax );
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					mov( attrEBX.string_vt, edx );
					canAccess( [edx] );
					mov( (type str.strRec [edx]).length, edx );
					sub( eax, edx );
					str.a_substr( attrEBX.string_vt, eax, edx );
					mov( eax, symECX.va.string_vt );
					pop( eax );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

					str.a_substr( attrEBX.string_vt, 0, eax );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the prefix string. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		freeAttr( theString );
		raise( ex.hlaerr );
	end noerror;

end ctMatchToStr;


// copyAttr - utility used by ctMax and ctMin:

//proc( "copyAttr" )
procedure copyAttr( var src:attr_t in ebx; var dest:attr_t in ecx );
	@noframe;
begin copyAttr;

	assert( src <> NULL );
	assert( dest <> NULL );
	pushfd();
	push( esi );
	push( edi );
	cld();
	mov( src, esi );
	mov( dest, edi );
	mov( @size( attr_t ), ecx );
	rep.movsb();
	pop( edi );
	pop( esi );
	popfd();
	ret();

end copyAttr;


// ctMax-
//
//	Handles the @Max function.

//proc( "ctMax" )
procedure ctMax( var attr:attr_t );
var
	leftValue		:attr_t;
	rightValue		:attr_t;
	cmpLeft			:attr_t;
	cmpRight		:attr_t;

begin ctMax;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( leftValue );
	defaultAttr( rightValue );
	defaultAttr( cmpLeft );
	defaultAttr( cmpRight );

	// Get the values from the source file "(string)":

	matchLParen();
	raiseErr( @c );

	// Must have at least one expression:

	constExpr( leftValue );


	// Handle the optional items here:

	forever

		freeAttr( rightValue );

		lex( esi );
		breakif( eax <> ',' );

		// Get a new operand from the parameter list:

		constExpr( rightValue );

		coerceOperands( leftValue, rightValue, tkn_at_min );
		raiseErr( @c );

		deepCopy
		( 
			leftValue, 
			leftValue.pType, 
			leftValue.symType, 
			cmpLeft 
		);
		deepCopy
		( 
			rightValue, 
			rightValue.pType, 
			rightValue.symType, 
			cmpRight 
		);
		lessThan( cmpLeft, cmpRight );
		raiseErr( @c );
		if( !cmpRight.boolean_vt ) then

			// rightValue > maxValue, so rightValue is the
			// new maxValue

			freeAttr( leftValue );
			deepCopy
			( 
				rightValue, 
				rightValue.pType, 
				rightValue.symType, 
				leftValue 
			);
		endif;
		
	endfor;
	if( eax <> ')' ) then

		HLAerror( "Syntax error in @Max - expected a ')'" nl );
		freeAttr( rightValue );
		freeAttr( leftValue );
		freeTkn( [ecx] );
		raise( ex.hlaerr );

	endif;
	freeAttr( rightValue );
	copyAttr( leftValue, attr );
	clc();

end ctMax;


// ctMin-
//
//	Handles the @Min function.

//proc( "ctMin" )
procedure ctMin( var attr:attr_t );
var
	minValue		:attr_t;
	leftValue		:attr_t;
	rightValue		:attr_t;
	cmpLeft			:attr_t;
	cmpRight		:attr_t;

begin ctMin;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( rightValue );
	begin noerror;

		begin error;

			// Get the values from the source file "(string)":

			matchLParen();
			raiseErr( @c );

			// Must have at least one expression:

			constExpr( leftValue );
			copyAttr( leftValue, minValue );


			// Handle the optional items here:

			forever

				lex( esi );
				breakif( eax <> ',' );

				// Get a new operand from the parameter list:

				constExpr( rightValue );

				coerceOperands( minValue, rightValue, tkn_at_min );
				exitif( @c ) error;

				deepCopy
				( 
					leftValue, 
					leftValue.pType, 
					leftValue.symType, 
					cmpLeft 
				);
				deepCopy
				( 
					rightValue, 
					rightValue.pType, 
					rightValue.symType, 
					cmpRight 
				);

				lessThan( cmpRight, cmpLeft );
				exitif( @c ) error;
				if( !cmpLeft.boolean_vt ) then

					// rightValue < minValue, so rightValue is the
					// new minValue

					freeAttr( minValue );
					deepCopy
					( 
						rightValue, 
						rightValue.pType, 
						rightValue.symType, 
						minValue 
					);

				endif;
				
			endfor;
			if( eax <> ')' ) then

				HLAerror( "Syntax error in @Min - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;
			copyAttr( minValue, attr );
			exit noerror;
			
		end error;
		raise( ex.hlaerr );
	end noerror;
	clc();
end ctMin;


// ctName-
//
//	Handles the @Name function.

//proc( "ctName" )
procedure ctName( var attr:attr_t in ebx ); @noframe;
begin ctName;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// We only allow a single identifier as an argument
		// to the @Name function:

		matchLParen();
		exitif( @c ) error;

		push( ebx );	// Save Attr across call to lex.
		lex( esi );
		cmp( ebx, ID_tc );
		pop( ebx );
		if( @ne ) then

			HLAerror( "@isClass expects an identifer as an argument" nl );
			exit error;

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// lowercase version of the identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.lcName );
				mov( tokenECX.trueName, eax );

			else

				// If the alloc flag is false, then we need to
				// make a copy of the trueName item:

				str.a_cpy( tokenECX.trueName );

			endif;

			mov( eax, attrEBX.string_vt );
			xor( eax, eax );
			mov( eax, attrEBX.dword_vt[4] );
			mov( eax, attrEBX.dword_vt[8] );
			mov( eax, attrEBX.dword_vt[12] );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			mustMatchRParen();
			clc();
			ret();

		endif;

	end error;
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctName;


// ctNoAlignStack-
//
//	Handles the @NoAlignStack function.

//proc( "ctNoAlignStack" )
procedure ctNoAlignStack( var attr:attr_t in ebx ); @noframe;
begin ctNoAlignStack;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultStackAlign, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoAlignStack;


// ctAlignStack-
//
//	Handles the @AlignStack function.

//proc( "ctAlignStack" )
procedure ctAlignStack( var attr:attr_t in ebx ); @noframe;
begin ctAlignStack;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultStackAlign, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctAlignStack;


// ctNoDisplay-
//
//	Handles the @NoDisplay function.

//proc( "ctNoDisplay" )
procedure ctNoDisplay( var attr:attr_t in ebx ); @noframe;
begin ctNoDisplay;

	canAccess( [ebx] );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultDisplay, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoDisplay;


// ctNoEnter-
//
//	Handles the @NoEnter function.

//proc( "ctNoEnter" )
procedure ctNoEnter( var attr:attr_t in ebx ); @noframe;
begin ctNoEnter;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultEnter, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoEnter;


// ctNoFrame-
//
//	Handles the @NoFrame function.

//proc( "ctNoFrame" )
procedure ctNoFrame( var attr:attr_t in ebx ); @noframe;
begin ctNoFrame;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultFrame, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoFrame;


// ctNoLeave-
//
//	Handles the @NoLeave function.

//proc( "ctNoLeave" )
procedure ctNoLeave( var attr:attr_t in ebx ); @noframe;
begin ctNoLeave;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultLeave, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoLeave;


// ctNorLessChar-
//
//	Handles the @NorLessChar function.
//
//	@NorLessChar( string, char, n{, remainder{, matched}} )

//proc( "ctNorLessChar" )
procedure ctNorLessChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorLessChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorLessChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorLessChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorLessChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( ecx < n.uns32_vt ) do

					cmp( al, [edx+ecx] );
					breakif( @ne );
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is different:
				
				cmp( al, [edx+ecx] );
				exitif( @e ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorLessChar;


// ctNorLessCset-
//
//	Handles the @NorLessCset function.
//
//	@NorLessCset( string, cset, n, remainder, matched )

//proc( "ctNorLessCset" )
procedure ctNorLessCset( var attr:attr_t );
var
	theCset			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorLessCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorLessCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorLessCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorLessCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( ecx < n.uns32_vt ) do

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					breakif( @nc );
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is not in the cset:
				
				movzx( (type char [edx+ecx]), eax );
				bt( eax, theCset.cset_vt );
				exitif( @c ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorLessCset;


// ctNorLessIChar-
//
//	Handles the @NorLessIChar function.
//
// @NorLessIChar( string, char, n, remainder, matched )

//proc( "ctNorLessIChar" )
procedure ctNorLessIChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorLessIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorLessIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorLessIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorLessIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while( ecx < n.uns32_vt ) do

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						breakif( @ne );

					endif;
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the n characters is different:
				
				mov( [edx+ecx], ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;
				cmp( al, ah );
				exitif( @e ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [edx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [edx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorLessIChar;


// ctNorMoreChar-
//
//	Handles the @NorMoreChar function.

//proc( "ctNorMoreChar" )
procedure ctNorMoreChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorMoreChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorMoreChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorMoreChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorMoreChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or more characters in the string:

				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( -1, ecx );
				repeat

					inc( ecx );
					
				until
				( 
						al <> [edx+ecx] 
					||	ecx >= (type str.strRec [edx]).length
				);

				// Make sure we've matched at least n characters:

				exitif( ecx < n.uns32_vt ) rtnFalse;
				

				// We'll, we've matched at least n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorMoreChar;


// ctNorMoreCset-
//
//	Handles the @NorMoreCset function.
//
//	@NorMoreCset( string, cset, n, remainder, matched )

//proc( "ctNorMoreCset" )
procedure ctNorMoreCset( var attr:attr_t  );
var
	theCset			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorMoreCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorMoreCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorMoreCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorMoreCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( -1, ecx );
				repeat

					inc( ecx );
					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					
				until( @nc || ecx >= (type str.strRec [edx]).length);
				
				// If there weren't at least n characters in the cset,
				// then return false:

				exitif( ecx < n.uns32_vt ) rtnFalse;


				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorMoreCset;


// ctNorMoreIChar-
//
//	Handles the @NorMoreIChar function.

//proc( "ctNorMoreIChar" )
procedure ctNorMoreIChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNorMoreIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fourth "
						"@NorMoreIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fifth "
							"@NorMoreIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NorMoreIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( 0, ecx );
				repeat

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						breakif( @ne );

					endif;
					inc( ecx );
					
				until( ecx >= (type str.strRec [edx]).length );
				exitif( ecx < n.uns32_vt ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNorMoreIChar;


// ctNoStackAlign-
//
//	Handles the @NoStackAlign function.

//proc( "ctNoStackAlign" )
procedure ctNoStackAlign( var attr:attr_t in ebx ); @noframe;
begin ctNoStackAlign;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultStackAlign, eax );
	xor( true, al );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctNoStackAlign;


// ctNtoMChar-
//
//	Handles the @NtoMChar function.

//proc( "ctNtoMChar" )
procedure ctNtoMChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	m				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNtoMChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	defaultAttr( m );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n, m )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@NtoMChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@NtoMChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NtoMChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' to 'm' characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				mov( attrEBX.string_vt, edx );
				while( ecx < m.uns32_vt ) do

					cmp( al, [edx+ecx] );
					breakif( @ne );
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the m characters is different:
				
				cmp( al, [edx+ecx] );
				exitif( @e ) rtnFalse;

				// Let's also make sure that we've matched
				// at least n characters"

				cmp( ecx, n.uns32_vt );
				exitif( @b ) rtnFalse;

				// We'll, we've matched n..m characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we haven't matched n..m characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNtoMChar;


// ctNtoMCset-
//
//	Handles the @NtoMCset function.
// @NtoMCset( string, cset, n, m{, remainder{, matched}} )

//proc( "ctNtoMCset" )
procedure ctNtoMCset( var attr:attr_t ); 
var
	theCset			:attr_t;
	n				:attr_t;
	m				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNtoMCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	defaultAttr( n );
	defaultAttr( m );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@NtoMCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@NtoMCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NtoMCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' to 'm' characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( ecx < m.uns32_vt ) do

					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					breakif( @nc );
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the m characters is not in the cset:
				
				movzx( (type char [edx+ecx]), eax );
				bt( eax, theCset.cset_vt );
				exitif( @c ) rtnFalse;

				// We've also got to verify that we've matched at least
				// n characters:

				exitif( ecx < n.uns32_vt ) rtnFalse;

				// We'll, we've matched n..m characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we've not matched n..m characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [edx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNtoMCset;


// ctNtoMIChar-
//
//	Handles the @NtoMIChar function.
//
// @NtoMIChar( string, char, n, m{, remainder{, matched}} );

//proc( "ctNtoMIChar" )
procedure ctNtoMIChar( var attr:attr_t );
var
	theChar			:attr_t;
	n				:attr_t;
	m				:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctNtoMIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	defaultAttr( n );
	defaultAttr( m );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n, m )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( m );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as fifth "
						"@NtoMIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as sixth "
							"@NtoMIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @NtoMIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' .. 'm' characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( ecx < m.uns32_vt ) do

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						breakif( @ne );

					endif;
					inc( ecx );
					
				endwhile;
				
				// Now, we've got to verify that the character
				// following the m characters is different:
				
				mov( [edx+ecx], ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;
				cmp( al, ah );
				exitif( @e ) rtnFalse;

				// We've also got to verify that we've matched at
				// least n characters.

				exitif( ecx < n.uns32_vt ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctNtoMIChar;


// ctOdd-
//
//	Handles the @Odd function.

//proc( "ctOdd" )
procedure ctOdd( var attr:attr_t in ebx ); @noframe;
begin ctOdd;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		if( !isNumber( al ) ) then
		
			HLAerror
			( 
				"@Odd expected an ordinal numeric argument, but encountered a ", 
				pTypeStrs[ eax*4 ], 
				" argument" 
				nl 
			);
			exit error;

		endif;

		// Okay, it was a numeric operand. Now see if it is odd.

		mov( attrEBX.byte_vt, cl );
		//zeroAttr( attr );
		zeroAttr( attrEBX );
		and( 1, cl );
		mov( cl, attrEBX.boolean_vt );
		mov( Boolean_pt, attrEBX.pType );
		mov( &boolean_ste, attrEBX.symType );
		clc();
		ret();

	end error;
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );
end ctOdd;


// ctOffset-
//
//	Handles the @Offset function.

//proc( "ctOffset" )
procedure ctOffset( var attr:attr_t );
begin ctOffset;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@Offset expects an identifer as an argument" nl );
			getRightParen();
			freeTkn( tokenECX );
			raise( ex.hlaerr );

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol's class is cIllegal, else it is defined.

			if( eax = tkn_undefID ) then
			
				mov( 0, eax );
			
			else
			
				mov( tokenECX.symNode, ecx );
				mov( symECX.offset, eax );
				
			endif;
			mov( attr, ebx );
			mov( eax, attrEBX.uns32_vt );
			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );
			mustMatchRParen();
			clc();

		endif;

	endif;

end ctOffset;


// ctOneChar-
//
//	Handles the @OneChar function.
//
// @OneChar( string, char{, remainder{, matched}} )

//proc( "ctOneChar" )
procedure ctOneChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, char)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;

			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @OneChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @OneChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match the character in the string:

				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				cmp( al, [edx] );
				exitif( @ne ) rtnFalse;
				
				// We'll, we've matched the characters.
				
				// Okay, we've matched exactly n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					dec( eax );
					str.a_substr( attrEBX.string_vt, 1, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, 1 );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneChar;


// ctOneCset-
//
//	Handles the @OneCset function.

//proc( "ctOneCset" )
procedure ctOneCset( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theCset			:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, start, length)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @OneCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @OneCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match a character in the set:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				movzx( (type char [edx]), eax );
				bt( eax, theCset.cset_vt );
				exitif( @nc ) rtnFalse;
				

				// We'll, we've matched a character from the set.
				
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					dec( eax );
					str.a_substr( attrEBX.string_vt, 1, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, 1 );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match a character. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneCset;


// ctOneIChar-
//
//	Handles the @OneIChar function.
//
// @OneIChar( string, char{, remainder{, matched}} )

//proc( "ctOneIChar" )
procedure ctOneIChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, char)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @OneIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @OneIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can a character in the string:
				// Don't use the toUpper macro here,
				// 'cause it doesn't check the full range.

				mov( theChar.char_vt, ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;


				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( [edx], al );
				toUpper( al );
				cmp( al, ah );
				exitif( @ne ) rtnFalse;
				

				// We'll, we've matched the character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.length( attrEBX.string_vt );
					dec( eax );
					str.a_substr( attrEBX.string_vt, 1, eax );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, 1 );
					mov( eax, symECX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctOneIChar;


// ctOneOrMoreChar-
//
//	Handles the @OneOrMoreChar function.

//proc( "ctOneOrMoreChar" )
procedure ctOneOrMoreChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneOrMoreChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@OneOrMoreChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneOrMoreChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @OneOrMoreChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or more characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				mov( attrEBX.string_vt, edx );
				while
				( 
						al = [edx+ecx] 
					&&	ecx < (type str.strRec [edx]).length
				) do
				
					inc( ecx );

				endwhile;

				// Make sure we've matched at least 1 character:

				exitif( ecx < 1 ) rtnFalse;
				

				// We'll, we've matched at least 1 character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneOrMoreChar;


// ctOneOrMoreCset-
//
//	Handles the @OneOrMoreCset function.
//
// @OneOrMoreCset( string, cset{, remainder{, matched}} );

//proc( "ctOneOrMoreCset" )
procedure ctOneOrMoreCset( var attr:attr_t );
var
	theCset			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneOrMoreCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@OneOrMoreCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneOrMoreCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @OneOrMoreCset - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( -1, ecx );
				repeat

					inc( ecx );
					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					
				until( @nc || ecx >= (type str.strRec [edx]).length);
				
				// If there weren't at least n characters in the cset,
				// then return false:

				exitif( ecx < 1 ) rtnFalse;


				// We'll, we've matched at least one character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneOrMoreCset;


// ctOneOrMoreIChar-
//
//	Handles the @OneOrMoreIChar function.

//proc( "ctOneOrMoreIChar" )
procedure ctOneOrMoreIChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneOrMoreIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@OneOrMoreIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@OneOrMoreIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @OneOrMoreIChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match one or more characters in the string:

				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( 0, ecx );
				repeat

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						breakif( @ne );

					endif;
					inc( ecx );
					
				until( ecx >= (type str.strRec [edx]).length );
				exitif( ecx < 1 ) rtnFalse;

				// We'll, we've matched up to n characters.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneOrMoreIChar;


// ctOneOrMoreWS-
//
//	Handles the @OneOrMoreWS function.
//
// @OneOrMoreWS( string{, remainder{, matched}} )

//proc( "ctOneOrMoreWS" )
procedure ctOneOrMoreWS( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctOneOrMoreWS;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as the second "
						"@OneOrMoreWS argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as the third "
							"@OneOrMoreWS argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @OneOrMoreWS - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or more characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while
				( 
						(type char [edx+ecx]) <= ' '
					&&	(type char [edx+ecx]) <> #0
					&&	ecx < (type str.strRec [edx]).length
				) do
				
					inc( ecx );

				endwhile;

				// Make sure we've matched at least 1 character:

				exitif( ecx < 1 ) rtnFalse;
				

				// We'll, we've matched at least 1 character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctOneOrMoreWS;


// ctParmOffset-
//
//	Handles the @ParmOffset function.

//proc( "ctParmOffset" )
procedure ctParmOffset( var attr:attr_t in ebx ); @noframe;
begin ctParmOffset;

	assert( attr <> NULL );	
	defaultAttr( [ebx] );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	mov( startParmsOffs, eax );
	mov( eax, attrEBX.dword_vt );
	clc();
	ret();

end ctParmOffset;


// ctParms-
//
//	Handles the @Parms function.

//proc( "ctParms" )
procedure ctParms( var attr:attr_t );
begin ctParms;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@parms expects an identifer as an argument" nl );
			getRightParen();
			freeTkn( tokenECX );
			raise( ex.hlaerr );

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol's class is cIllegal, else it is defined.

			mov( tokenECX.symNode, ecx );
			if( eax = tkn_undefID || !isproc( symECX.symClass ) ) then
			
				HLAerror
				( 
					"Expected a procedure, method, or iterator "
					"identifier in @parms" 
					nl 
				);
				//freeTkn( tokenECX );
				raise( ex.hlaerr );				
			
			else
			
				mov( tokenECX.symNode, ecx );
				mov( symECX.cproc.parmSize, eax );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( eax, attrEBX.dword_vt );
				mov( Uns32_pt, attrEBX.pType );
				mov( &uns32_ste, attrEBX.symType );
				mustMatchRParen();
				clc();
				
			endif;

		endif;

	endif;

end ctParms;


// ctPClass-
//
//	Handles the @PClass function.

//proc( "ctPClass" )
procedure ctPClass( var attr:attr_t );
begin ctPClass;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@pclass expects an identifer as an argument" nl );
			getRightParen();
			freeTkn( tokenECX );
			raise( ex.hlaerr );
		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol's class is cIllegal, else it is defined.

			if( eax = tkn_undefID ) then
			
				mov( notp_pc, al );
			
			else
			
				mov( tokenECX.symNode, ecx );
				mov( symECX.pClass, al );
				
			endif;
			mov( attr, ebx );
			canAccess( [ebx] );
			mov( al, attrEBX.boolean_vt );
			mov( Uns8_pt, attrEBX.pType );
			mov( &uns8_ste, attrEBX.symType );
			mustMatchRParen();
			clc();

		endif;

	endif;

end ctPClass;


// ctPeekChar-
//
//	Handles the @PeekChar function.
//
// @PeekChar( string, char{, remainder{, matched}} );

//proc( "ctPeekChar" )
procedure ctPeekChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctPeekChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, char)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @PeekChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@PeekChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @PeekChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match the character in the string:

				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				cmp( al, [edx] );
				exitif( @ne ) rtnFalse;
				
				// We'll, we've matched the characters.
				
				// Okay, we've matched a character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					// On a peek, we always return the whole string
					// as the remainder.

					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_cpy( attrEBX.string_vt );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					// On a peek, we always return the empty string
					// as the matched string.

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					str.a_cpy( "" );
					mov( eax, symECX.va.string_vt );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly the character. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctPeekChar;


// ctPeekCset-
//
//	Handles the @PeekCset function.
//
// @PeekCset( string, cset{, remainder, [cset] )

//proc( "ctPeekCset" )
procedure ctPeekCset( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	theCset			:attr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctPeekCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, cset)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @PeekCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@PeekCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @PeekCset - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match a character in the set:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				movzx( (type char [edx]), eax );
				bt( eax, theCset.cset_vt );
				exitif( @nc ) rtnFalse;
				

				// We'll, we've matched a character from the set.
				
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					// On a peek, we always return the whole string
					// as the remainder.

					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_cpy( attrEBX.string_vt );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					// On a peek, we always return the empty string
					// as the matched string.

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					str.a_cpy( "" );
					mov( eax, symECX.va.string_vt );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

				endif;


				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match a character. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );


			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctPeekCset;


// ctPeekIChar-
//
//	Handles the @PeekIChar function.

//proc( "ctPeekIChar" )
procedure ctPeekIChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctPeekIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file "(string, char)":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third @PeekIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@PeekIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror( "Syntax error in @PeekIChar - expected a ')'" nl );
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can a character in the string:
				// Don't use the toUpper macro here,
				// 'cause it doesn't check the full range.

				mov( theChar.char_vt, ah );
				if( ah in 'a'..'z' ) then

					and( $5f, ah );

				endif;


				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( [edx], al );
				toUpper( al );
				cmp( al, ah );
				exitif( @ne ) rtnFalse;
				

				// We'll, we've matched the character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					// On a peek, we always return the whole string
					// as the remainder.

					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_cpy( attrEBX.string_vt );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					// On a peek, we always return the empty string
					// as the matched string.

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					str.a_cpy( "" );
					mov( eax, symECX.va.string_vt );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we did not match exactly n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctPeekIChar;


// ctPeekWS-
//
//	Handles the @PeekWS function.

//proc( "ctPeekWS" )
procedure ctPeekWS( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctPeekWS;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as the second "
						"@PeekWS argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as the third "
							"@PeekWS argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @PeekWS - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can find a whitespace character at the start of the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				exitif
				( 
						(type char [edx]) > ' ' 
					||	(type char [edx]) = #0
				) rtnFalse;
				
			

				// As we're just doing a peek, return the
				// full string as the remainder and the
				// empty string as the matched value. 

				if( hasRemainder ) then
				
					mov( remainderSym, ecx );
					canAccess( [ecx] );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );
					str.a_cpy( attrEBX.string_vt );
					mov( eax, symECX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, ecx );
					canAccess( [ecx] );
					str.a_cpy( "" );
					mov( eax, symECX.va.string_vt );
					mov( &string_ste, symECX.symType );
					mov( String_pt, symECX.pType );
					mov( 4, symECX.objectSize );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctPeekWS;


/////////////////////////////////////////////////////////////////////////////
//
// ctPointer-
//
//	Handles the @Pointer function.

//proc( "ctPointer" )
procedure ctPointer( var attr:attr_t ); 
var				
	index		:dword;
	whichDWord	:attr_t;

begin ctPointer;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );
			mustMatchRParen();
			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@pointer function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			
			mov( attrEBX.dword_vt, ecx );
			xor( eax, eax );
			mov( eax, attrEBX.dword_vt[ 0] );
			mov( eax, attrEBX.dword_vt[ 4] );
			mov( eax, attrEBX.dword_vt[ 8] );
			mov( eax, attrEBX.dword_vt[12] );
			mov( eax, attrEBX.dword_vt[16] );
			mov( eax, attrEBX.dword_vt[20] );
			mov( eax, attrEBX.dword_vt[24] );
			mov( eax, attrEBX.dword_vt[28] );

			mov( ecx, attrEBX.p.constant );
			mov( NULL, attrEBX.p.dispMinusAdrs );
			mov( NULL, attrEBX.p.dispBaseAdrs );
			malloc( @size( staticExpr_t ) );
			mov( Pointer_pt, attrEBX.pType );
			mov( &pointer_ste, attrEBX.symType );
			mov( eax, ebx );
			str.a_cpy( "@here" );
			mov( eax, (type staticExpr_t [ebx]).trueName );
			mov( eax, (type staticExpr_t [ebx]).lcName );
			mov( 0, (type staticExpr_t [ebx]).hashValue );
			mov( 0, (type staticExpr_t [ebx]).lineNumber );
			mov( &pointer_ste, (type staticExpr_t [ebx]).symbol );
			mov( dataSegment, (type staticExpr_t [ebx]).seg );
			mov( curLexLevel, (type staticExpr_t [ebx]).lexLevel );	

			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;

end ctPointer;


///////////////////////////////////////////////////////////////////////////
//
// ctPtype-
//
//	Handles the @Ptype( id ) function.
//

//proc( "ctPtype" )
procedure ctPtype( var attr:attr_t ); 
begin ctPtype;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@ptype expects an identifer as an argument" nl );
			getRightParen();
			freeTkn( tokenECX );
			raise( ex.hlaerr );
		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the lexer returns tkn_undefID, then
			// the symbol's class is cIllegal, else it is defined.

			if( eax = tkn_undefID ) then
			
				mov( Undefined_pt, al );
			
			else
			
				mov( tokenECX.symNode, ecx );
				mov( symECX.pType, al );
				
			endif;
			mov( attr, ebx );
			canAccess( [ebx] );
			mov( al, attrEBX.byte_vt );
			mov( Uns8_pt, attrEBX.pType );
			mov( &uns8_ste, attrEBX.symType );
			mustMatchRParen();
			clc();

		endif;

	endif;

end ctPtype;


// ctQword-
//
//	Handles the @Qword function.

//proc( "ctQword" )
procedure ctQword( var attr:attr_t ); @nodisplay; @nostackalign;
var
	index		:dword;
	whichQWord	:attr_t;

begin ctQword;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@qword function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first lword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichQWord );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichQWord.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @qword must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichQWord.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichQWord.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichQWord.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @qword"
						nl
					);
					exit error;

				endif;
				mov( whichQWord.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @qword, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as second @qword argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an QWORD object,
				// we only need to transfer 8 bytes, so compute
				// the minimum of objectsize-index and 8 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 8 ) then

					mov( 8, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the QWORD,
				// if the original data type (plus the index) had
				// fewer than 8 bytes:

				while( edx < 8 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the QWORD:

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			else // We've got a string or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( eax >= ecx ) then

					HLAerror
					(
						"Second argument to @qword indexes beyond the "
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 8 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 8 ) then

					mov( 8, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the QWORD,
				// if the original data type (plus the index) had
				// fewer than 8 bytes:

				while( esi < 8 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( QWord_pt, attrEBX.pType );
			mov( &qword_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctQword;


// ctRandom-
//
//	Handles the @Random function.

//proc( "ctRandom" )
procedure ctRandom( var attr:attr_t in ebx ); @noframe;
begin ctRandom;

	assert( attr <> NULL );
	defaultAttr( attrEBX );
	rand.uniform();
	mov( eax, attrEBX.uns32_vt );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	clc();
	ret();

end ctRandom;


// ctRandomize-
//
//	Handles the @Randomize function.

//proc( "ctRandomize" )
procedure ctRandomize( var attr:attr_t in ebx ); @noframe;
begin ctRandomize;

	assert( attr <> NULL );
	defaultAttr( attrEBX );
	rand.randomize();
	rand.uniform();
	mov( eax, attrEBX.uns32_vt );
	mov( Uns32_pt, attrEBX.pType );
	mov( &uns32_ste, attrEBX.symType );
	clc();
	ret();

end ctRandomize;


// ctRead-
//
//	Handles the @Read function.

//proc( "ctRead" )
procedure ctRead( var attr:attr_t );
var
	saveESI: dword;
	saveEDI: dword;

begin ctRead;

	assert( attr <> NULL );
	defaultAttr( attr );
	if( openReadHandle = 0 ) then

		HLAerror( "@read attempted, but input file is not open" nl );
		str.a_cpy( "" );
		raise( ex.hlaerr );

	else
		
		try

			mov( edi, saveEDI );
			mov( esi, saveESI );
			fileio.a_gets( openReadHandle );
			mov( attr, ebx );
			canAccess( [ebx] );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			mov( false, lastWasEOF );
			
		  exception( ex.EndOfFile )

			mov( saveESI, esi );
			mov( saveEDI, edi );
			if( lastWasEOF ) then

				HLAerror( "EOF reached when reading data from file" nl );
				raise( ex.hlaerr );

			else

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( -1, attrEBX.int32_vt );
				mov( Int32_pt, attrEBX.pType );
				mov( &int32_ste, attrEBX.symType );
				mov( true, lastWasEOF );

			endif;

		  exception( ex.MemoryAllocationFailure )

			raise( ex.MemoryAllocationFailure );
			
		  anyexception
		  
			mov( saveESI, esi );
			mov( saveEDI, edi );
		  	HLAerror( "Error attempting to read data from file" );
		  	raise( ex.hlaerr );
		  	
		endtry;														  

	endif;
	clc();

end ctRead;




// ctReal32-
//
//	Handles the @Real32 function.

//proc( "ctReal32" )
procedure ctReal32( var attr:attr_t );
var
	index		:dword;
	whichDWord	:attr_t;

begin ctReal32;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@real32 function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first dword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichDWord );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichDWord.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @real32 must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichDWord.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichDWord.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichDWord.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @real32"
						nl
					);
					exit error;

				endif;
				mov( whichDWord.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @real32, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as second @real32 argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						"+3 bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an DWORD object,
				// we only need to transfer 4 bytes, so compute
				// the minimum of objectsize-index and 4 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 4 ) then

					mov( 4, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the DWORD,
				// if the original data type (plus the index) had
				// fewer than 4 bytes:

				while( edx < 4 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the LWORD:

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			else // We've got a string or a UString

				mov( attrEBX.string_vt, edx );
				if( eax >= (type str.strRec [edx]).length ) then

					HLAerror
					(
						"Second argument to @real32 indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 4 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 4 ) then

					mov( 4, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the REAL32,
				// if the original data type (plus the index) had
				// fewer than 4 bytes:

				while( esi < 4 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( Real32_pt, attrEBX.pType );
			mov( &real32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctReal32;


// ctReal64-
//
//	Handles the @Real64 function.

//proc( "ctReal64" )
procedure ctReal64( var attr:attr_t );
var
	index		:dword;
	whichQWord	:attr_t;

begin ctReal64;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@real64 function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first lword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichQWord );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichQWord.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @real64 must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichQWord.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichQWord.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichQWord.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @real64"
						nl
					);
					exit error;

				endif;
				mov( whichQWord.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @real64, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as second @real64 argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an REAL64 object,
				// we only need to transfer 8 bytes, so compute
				// the minimum of objectsize-index and 8 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 8 ) then

					mov( 8, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the REAL64,
				// if the original data type (plus the index) had
				// fewer than 8 bytes:

				while( edx < 8 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the REAL64:

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			else // We've got a string or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( eax >= (type str.strRec [edx]).length ) then

					HLAerror
					(
						"Second argument to @real64 indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 8 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 8 ) then

					mov( 8, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the REAL64,
				// if the original data type (plus the index) had
				// fewer than 8 bytes:

				while( esi < 8 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( Real64_pt, attrEBX.pType );
			mov( &real64_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctReal64;


// ctReal80-
//
//	Handles the @Real80 function.

//proc( "ctReal80" )
procedure ctReal80( var attr:attr_t );
//
// @Real80( expr{, byteOffset} );

var
	index		:dword;
	whichTByte	:attr_t;

begin ctReal80;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@real80 function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first lword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichTByte );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichTByte.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @real80 must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichTByte.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichTByte.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichTByte.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @real80"
						nl
					);
					exit error;

				endif;
				mov( whichTByte.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @real80, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as second @real80 argument must be "
						"less than " nl
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;


				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an REAL80 object,
				// we only need to transfer 10 bytes, so compute
				// the minimum of objectsize-index and 10 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 10 ) then

					mov( 10, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the REAL80,
				// if the original data type (plus the index) had
				// fewer than 10 bytes:

				while( edx < 10 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the REAL64:

				xor( eax, eax );
				mov( ax,   attrEBX.word_vt[10] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			else // We've got a string or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( eax >= ecx ) then

					HLAerror
					(
						"Second argument to @real80 indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 10 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 10 ) then

					mov( 10, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the REAL80,
				// if the original data type (plus the index) had
				// fewer than 10 bytes:

				while( esi < 10 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov( ax,  attrEBX.word_vt [10] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( Real80_pt, attrEBX.pType );
			mov( &real80_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctReal80;


// ctRIndex-
//
//	Handles the @RIndex function.
//
// @RIndex( string, index, searchStr );

//proc( "ctRIndex" )
procedure ctRIndex( var attr:attr_t );
var
	strExpr1	:attr_t;
	strExpr2	:attr_t;

begin ctRIndex;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr1 );
	defaultAttr( strExpr2 );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr1 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getString( strExpr2 );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib RINDEX2 function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );

			str.rindex3
			( 
				strExpr1.string_vt, 
				attrEBX.uns32_vt, 
				strExpr2.string_vt 
			);
			if( strExpr1.pType = Utf8_pt ) then

				// If it's a UTF-8 string, then convert
				// the byte index obtained above into a
				// UTF-8 character index:

				byteToCharUTF8( strExpr1.string_vt, eax );

			endif;
			mov( eax, attrEBX.uns32_vt );
			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	pushfd();
	freeAttr( strExpr1 );
	freeAttr( strExpr2 );
	popfd();

end ctRIndex;


// ctSection-
//
//	Handles the @Section function.

//proc( "ctSection" )
procedure ctSection( var attr:attr_t in ebx ); @noframe;
begin ctSection;

	#print( "TODO: ctSection function" );

	ret();
end ctSection;


// ctSin-
//
//	Handles the @Sin function.

//proc( "ctSin" )
procedure ctSin( var attr:attr_t in ebx ); @noframe;
begin ctSin;

	assert( attr <> NULL );
	finit();
	fclex();
	matchLParen();
	jc badSIN;
	constExpr( [ebx] );
	mustMatchRParen();
	makeReal80( attrEBX );
	fsin();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );	
	ret();

badSIN:
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctSin;


// ctSize-
//
//	Handles the @Size function.

//proc( "ctSize" )
procedure ctSize( var attr:attr_t );
begin ctSize;

	assert( attr <> NULL );
	matchLParen();

	// Check for an identifier or an expression:

	getIDorExpr( attr );
	if( eax = ID_tc ) then

		defaultAttr( attr );
		
		// It was an identifier. Return the size
		// associated with that ID. Note that
		// ECX points at the token for the identifier,
		// we know it is an ID, and the strings for
		// the ID have already been deallocated.

		mov( attr, ebx );
		canAccess( [ebx] );
		if( ecx <> NULL ) then

			mov( symECX.objectSize, eax );

		else

			xor( eax, eax );

		endif;
		mov( eax, attrEBX.uns32_vt );
		mov( Uns32_pt, attrEBX.pType );
		mov( &uns32_ste, attrEBX.symType );
		mustMatchRParen();
		clc();

	else // must be const_tc, so we've got a constant expression.

		mov( attr, ebx );
		canAccess( [ebx] );
		mov( attrEBX.symType, edx );
		mov( symEDX.objectSize, eax );
		push( eax );
		freeAttr( attrEBX );
		defaultAttr( attr );
		pop( eax );
		mov( eax, attrEBX.uns32_vt );
		mov( Uns32_pt, attrEBX.pType );
		mov( &uns32_ste, attrEBX.symType );
		mustMatchRParen();
		clc();

	endif;

end ctSize;


// ctSqrt-
//
//	Handles the @Sqrt function.

//proc( "ctSqrt" )
procedure ctSqrt( var attr:attr_t in ebx ); @noframe;
begin ctSqrt;

	assert( attr <> NULL );
	finit();
	fclex();
	matchLParen();
	jc badSQRT;
	constExpr( [ebx] );
	mustMatchRParen();
	makeReal80( attrEBX );
	fsqrt();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );	
	ret();

badSQRT:
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctSqrt;


// ctSubstr-
//
//	Handles the @Substr function.

//proc( "ctSubstr" )
procedure ctSubstr( var attr:attr_t );
var
	start	:attr_t;
	len		:attr_t;

begin ctSubstr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( start );
	defaultAttr( len );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( start );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( len );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib substr function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( attrEBX.string_vt, edx );
			mov( (type str.strRec [edx]).length, eax );
			if( eax > start.uns32_vt ) then

				if( attrEBX.pType = Utf8_pt ) then

					// If it's a UTF-8 string, then use
					// character indexes rather than byte indexes.

					utf8Index( attrEBX.string_vt, start.uns32_vt );
					mov( eax, start.uns32_vt );
					utf8Index2
					( 
						attrEBX.string_vt, 
						len.uns32_vt, 
						start.uns32_vt 
					);
					mov( eax, len.uns32_vt );

				endif;

				str.a_substr
				( 
					attrEBX.string_vt, 
					start.uns32_vt,
					len.uns32_vt 
				);

			else

				// Starting index is out of bounds, just
				// return the empty string as the result:

				str.a_cpy( "" );

			endif;
			assert( attrEBX.string_vt <> NULL );
			strfree( attrEBX.string_vt );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( start );
		freeAttr( len );
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctSubstr;


// ctStackAlign-
//
//	Handles the @StackAlign function.

//proc( "ctStackAlign" )
procedure ctStackAlign( var attr:attr_t in ebx ); @noframe;
begin ctStackAlign;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( defaultStackAlign, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctStackAlign;


// ctStaticName-
//
//	Handles the @StaticName function.

//proc( "ctStaticName" )
procedure ctStaticName( var attr:attr_t );
begin ctStaticName;

	assert( attr <> NULL );
	zeroAttr( attr );
	matchLParen();
	if( @nc ) then

		lex( esi );
		if( ebx <> ID_tc ) then

			HLAerror( "@StaticName expects an identifer as an argument" nl );
			freeTkn( tokenECX );
			raise( ex.hlaerr );

		else

			assert( tokenECX.isID );

			// If the "alloc" flag is true, then we need to
			// deallocate the storage assocated with the
			// identifier:

			if( tokenECX.alloc ) then

				assert( tokenECX.trueName <> NULL );
				assert( tokenECX.lcName <> NULL );
				strfree( tokenECX.trueName );
				strfree( tokenECX.lcName );

			endif;

			// If the static ID field is NULL, then return
			// the empty string, else return a copy of the
			// static name.

			mov( tokenECX.symNode, edx );
			canAccess( [edx] );
			if( symEDX.externName = NULL ) then

				str.a_cpy( "" );

			else

				str.a_cpy( symEDX.externName );

			endif;

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			mustMatchRParen();
		endif;

	endif;

end ctStaticName;


// ctStrBrk-
//
//	Handles the @StrBrk function.

//proc( "ctStrBrk" )
procedure ctStrBrk( var attr:attr_t );
var
	strExpr1	:attr_t;
	csExpr2		:attr_t;

begin ctStrBrk;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr1 );
	defaultAttr( csExpr2 );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr1 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( csExpr2 );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.brk2 function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			if( strExpr1.pType = Utf8_pt ) then

				// If it's a UTF-8 string, then convert the
				// character index into a byte index:

				utf8Index( strExpr1.string_vt, attrEBX.uns32_vt );
				mov( eax, attrEBX.uns32_vt );

			endif;
			str.brk3
			( 
				strExpr1.string_vt, 
				attrEBX.uns32_vt, 
				csExpr2.cset_vt 
			);
			if( strExpr1.pType = Utf8_pt && eax <> -1 ) then

				// If it's a UTF-8 string, then convert the
				// byte index into a character index:

				byteToCharUTF8( strExpr1.string_vt, eax );

			endif;
			mov( eax, attrEBX.uns32_vt );
			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	pushfd();
	freeAttr( strExpr1 );
	freeAttr( csExpr2 );
	popfd();

end ctStrBrk;


// ctString-
//
//	Handles the @String function.

//proc( "ctString" )
procedure ctString( var attr:attr_t );
var
	s:string;
	saveForceString: boolean;

begin ctString;

	assert( attr <> NULL );
	mov( ForceString, al );
	mov( al, saveForceString );
	mov( true, ForceString ); // So TEXT objects don't get expanded.

	tstralloc( 1024 );		// For most objects, this should be large enough
	mov( eax, s ); 			//  to hold the string result.
	defaultAttr( attr );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			constExpr( attr );
			mustMatchRParen();
			mov( attr, ebx );
			canAccess( [ebx] );
			movzx( attrEBX.pType, eax );
			switch( eax )

				case( Byte_pt  	 )
					str.put( s, attrEBX.byte_vt );

				case( Word_pt	 )
					str.put( s, attrEBX.word_vt );

				case( DWord_pt	 )
					conv.setUnderscores( true );
					str.put( s, attrEBX.dword_vt );
					conv.setUnderscores( false );

				case( QWord_pt	 )
					conv.setUnderscores( true );
					str.put( s, attrEBX.qword_vt );
					conv.setUnderscores( false );

				case( TByte_pt	 )
					conv.setUnderscores( true );
					str.put( s, attrEBX.tbyte_vt );
					conv.setUnderscores( false );

				case( LWord_pt	 )
					conv.setUnderscores( true );
					str.put( s, attrEBX.lword_vt );
					conv.setUnderscores( false );

				case( Uns8_pt	 )
					str.put( s, attrEBX.uns8_vt );

				case( Uns16_pt	 )
					str.put( s, attrEBX.uns16_vt );

				case( Uns32_pt	 )
					str.put( s, attrEBX.uns32_vt );

				case( Uns64_pt	 )
					conv.u64ToStr( attrEBX.uns64_vt, 1, ' ', s );

				case( Uns128_pt	 )
					conv.u128ToStr( attrEBX.uns128_vt, 1, ' ', s );

				case( Int8_pt	 )
					str.put( s, attrEBX.int8_vt );

				case( Int16_pt	 )
					str.put( s, attrEBX.int16_vt );

				case( Int32_pt	 )
					str.put( s, attrEBX.int32_vt );

				case( Int64_pt	 )
					conv.i64ToStr( attrEBX.int64_vt, 1, ' ', s );

				case( Int128_pt	 )
					conv.i128ToStr( attrEBX.int128_vt, 1, ' ', s );

				case( Real32_pt	 )
					finit();
					fclex();
					conv.e32ToStr( attrEBX.real32_vt, 15, s );

				case( Real64_pt  )
					finit();
					fclex();
					conv.e64ToStr( attrEBX.real64_vt, 20, s );

				case( Real80_pt	 )
					finit();
					fclex();
					conv.e80ToStr( attrEBX.real80_vt, 24, s );

				case( Boolean_pt )
					str.put( s, attrEBX.boolean_vt );

				case( Char_pt 	 )
					str.put( s, attrEBX.char_vt );

				case( XChar_pt	 )
					str.put( s, (type char attrEBX.xchar_vt)  );

				case( Unicode_pt )
					str.put( s, attrEBX.word_vt );

				case
				( 
					String_pt,
					Utf8_pt,
					Text_pt
				)
					mov( attrEBX.string_vt, eax );
					mov( eax, s );

				case( UString_pt )
					unicodeToAnsi( attrEBX.string_vt );
					mov( attrEBX.string_vt, eax );
					mov( eax, s );

				case( Cset_pt	 )
					str.put( s, attrEBX.cset_vt );

				case( XCset_pt	 )
					str.put( s, attrEBX.cset_vt );

				default
					HLAerror( "Unexpected data type in @string function" nl );
					freeAttr( attrEBX );
					raise( ex.hlaerr );

			endswitch;

			str.a_cpy( s );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	mov( saveForceString, al );
	mov( al, ForceString );

end ctString;


// ctStrSet-
//
//	Handles the @StrSet function.

//proc( "ctStrSet" )
procedure ctStrSet( var attr:attr_t );
var
	charExpr	:attr_t;
	n			:attr_t;

begin ctStrSet;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( charExpr );
	defaultAttr( n );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getChar( charExpr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( n );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.setstr function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			str.a_setstr
			( 
				charExpr.char_vt, 
				n.uns32_vt 
			);
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( charExpr );
		freeAttr( n );
		raise( ex.hlaerr );
	end noerror;

end ctStrSet;


// ctStrSpan-
//
//	Handles the @StrSpan function.

//proc( "ctStrSpan" )
procedure ctStrSpan( var attr:attr_t );
var
	strExpr1	:attr_t;
	csExpr2		:attr_t;

begin ctStrSpan;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( strExpr1 );
	defaultAttr( csExpr2 );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( strExpr1 );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( csExpr2 );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.brk2 function to
			// compute the result:

			mov( attr, ebx );
			canAccess( [ebx] );
			if( strExpr1.pType = Utf8_pt ) then

				// If it's a UTF-8 string, then convert the
				// character index into a byte index:

				utf8Index( strExpr1.string_vt, attrEBX.uns32_vt );
				mov( eax, attrEBX.uns32_vt );

			endif;
			str.span3
			( 
				strExpr1.string_vt, 
				attrEBX.uns32_vt, 
				csExpr2.cset_vt 
			);
			if( strExpr1.pType = Utf8_pt && eax <> -1 ) then

				// If it's a UTF-8 string, then convert the
				// byte index into a character index:

				byteToCharUTF8( strExpr1.string_vt, eax );

			endif;

			mov( eax, attrEBX.uns32_vt );
			mov( Int32_pt, attrEBX.pType );
			mov( &int32_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	pushfd();
	freeAttr( strExpr1 );
	freeAttr( csExpr2 );
	popfd();

end ctStrSpan;


// ctTan-
//
//	Handles the @Tan function.

//proc( "ctTan" )
procedure ctTan( var attr:attr_t in ebx ); @noframe;
begin ctTan;

	assert( attr <> NULL );
	finit();
	fclex();
	matchLParen();
	jc badTAN;
	constExpr( [ebx] );
	mustMatchRParen();
	//makeReal80( attr );
	makeReal80( attrEBX );
	fsincos();
	fdivp();
	fstp( attrEBX.real80_vt );
	mov( Real80_pt, attrEBX.pType );
	mov( &real80_ste, attrEBX.symType );	
	ret();

badTAN:
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctTan;




// ctTime-
//
//	Handles the @Time function.

//proc( "ctTime" )
procedure ctTime( var attr:attr_t );
var
	theTime:	time.timerec;
	timeStr:	string;
	ampm:		boolean;

begin ctTime;

	assert( attr <> NULL );
	defaultAttr( attr );
	tstralloc( 32 );
	mov( eax, timeStr );
	time.curTime( theTime );
	mov( false, ampm );
	if( theTime.hours >= 12 ) then

		sub( 12, theTime.hours );
		mov( true, ampm );

	endif;
	conv.u16ToStr( theTime.hours, 2, '0', timeStr );
	str.cat( ":", timeStr );
	str.catu8Size( timeStr, theTime.mins, 2, '0' );
	str.cat( ":", timeStr );
	str.catu8Size( timeStr, theTime.secs, 2, '0' );
	if( ampm ) then

		str.cat( " PM", timeStr );

	else

		str.cat( " AM", timeStr );

	endif;
	mov( attr, ebx );
	canAccess( [ebx] );
	str.a_cpy( timeStr );
	mov( eax, attrEBX.string_vt );
	mov( String_pt, attrEBX.pType );
	mov( &string_ste, attrEBX.symType );
	clc();

end ctTime;


// ctTokenize-
//
//	Handles the @Tokenize function.
//
// @tokenize( string )-
//
// Returns an array of individual strings

//proc( "ctTokenize" )
procedure ctTokenize( var attr:attr_t );
const
	maxItems	:= 1024;		// Arbitrary limit on # of string tokens.

var
	dummy		:symNodePtr_t;
	itemCnt		:uns32;
	doQuotes	:boolean;
	doParens	:boolean;
	doBrackets	:boolean;
	doBraces	:boolean;
	doApost		:boolean;

	align(4);

	expr		:attr_t;			// String to tokenize
	csDelims	:attr_t;			// Delimiters separating words
	csQuotes	:attr_t;			// Quotes that capture text
	startPosn	:attr_t;			// Starting index into string.
	tknzdStrs	:string[maxItems];	// Holds tokens.

readonly
	tknzArrayStr :string := "String Array";

	//proc( "getTo" )
	procedure getTo( c:char in al ); @noframe;
	begin getTo;

		skipToQuote:
			cmp( (type char [edx]), #0 );
			je rtnGetTo;
			inc( edx );
			cmp( al, [edx] );
			jne skipToQuote;

			// We hit the quote character. 

			inc( edx );		// Include quoted char in string.

		rtnGetTo:
			ret();

	end getTo;

begin ctTokenize;

	assert( attr <> NULL );
	defaultAttr( expr );
	defaultAttr( attr );
	defaultAttr( csDelims );	// Note: clears char codes #128..#255
	defaultAttr( csQuotes );	// in the xcset field.
	defaultAttr( startPosn );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			getString( expr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getUnsigned( startPosn );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( csDelims );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( csQuotes );
			exitif( @c ) error;
			mustMatchRParen();
			// If the csDelims string is the empty set, then
			// use a standard set of delimiters (whitespace).

			mov( (type dword csDelims.cset_vt[ 0 ]), eax );
			or ( (type dword csDelims.cset_vt[ 4 ]), eax );
			or ( (type dword csDelims.cset_vt[ 8 ]), eax );
			or ( (type dword csDelims.cset_vt[ 12]), eax );
			if( @z ) then

				cs.cpy
				(
					{ ' ', #1..#$1f, #$7f, ','},
					csDelims.cset_vt
				);

			endif;

			// It would be nice to be able to use the HLA stdlib
			// str.tokenize function here, but the str.tokenize
			// function doesn't handle the quotes parameter we
			// require.

			mov( false, doQuotes   );	
			mov( false, doParens   );	
			mov( false, doBrackets );
			mov( false, doBraces   );	
			mov( false, doApost	   );

			// doQuotes := '"' in csQuotes:

			mov( '"', eax );
			bt( eax, csQuotes.cset_vt );
			rcl( 1, doQuotes );	

			// doApost := '''' in csQuotes:

			mov( '''', eax );
			bt( eax, csQuotes.cset_vt );
			rcl( 1, doApost );	

			// doParens := '(' in csQuotes:

			mov( '(', eax );
			bt( eax, csQuotes.cset_vt );
			rcl( 1, doParens );	

			// doBrackets := '[' in csQuotes:

			mov( '[', eax );
			bt( eax, csQuotes.cset_vt );
			rcl( 1, doBrackets );	

			// doBraces := '{' in csQuotes:

			mov( '{', eax );
			bt( eax, csQuotes.cset_vt );
			rcl( 1, doBraces );
			
			// Start off with no items in our array.

			mov( 0, itemCnt );
			
			// Scan the string to "tokenize" it:
			
			mov( expr.string_vt, edx );
			canAccess( [edx] );
			push( esi );
			push( edi );
			pushfd();
			cld();
			forever
			
				// Skip over leading delimiter characters
				// Just to be on the safe side, do not allow #0 as
				// a character in the csDelims set while doing this:

				and( $fe, (type byte csDelims.cset_vt));
				dec( edx );
				xor( eax, eax );
				repeat

					inc( edx );
					mov( [edx], al );
					bt( eax, csDelims.cset_vt );

				until( @nc );

				// We're either at the end of the string or the start
				// of a character sequence to grab.

				breakif( al = 0 );	// Bail if at end of string.

				// Okay, we're at the start of a character sequence.
				// First, check to see if this is one of our quoting
				// characters.

				mov( edx, ecx ); 	// Save ptr to start of string.
				if( al = '"' && doQuotes ) then

					getTo( '"' );

				elseif( al = '''' && doApost ) then

					getTo( '''' );

				elseif( al = '(' && doParens ) then

					getTo( ')' );

				elseif( al = '[' && doBrackets ) then

					getTo( ']' );

				elseif( al = '{' && doBraces ) then

					getTo( '}' );

				else

					// Not a special quoting object, so get everything
					// up to the next delimiter. Treat end of string
					// as a delimiter for our purposes:

					or( 1, (type byte csDelims.cset_vt));
					dec( edx );
					repeat

						inc( edx );
						movzx( (type char [edx]), eax );
						bt( eax, csDelims.cset_vt );

					until( @c );

				endif;
				
				// Okay, we've gotten a string. Grab all the chars
				// from ecx..edx (if any).

				mov( ecx, esi );			// Start of string.
				neg( ecx );					// Compute string length.
				add( edx, ecx );
				breakif( @z );				// Bail if empty string
				stralloc( ecx );			// Allocate storage for string
				mov( ecx, (type str.strRec [eax]).length );
				mov( eax, edi );
				rep.movsb();				// Copy string data
				mov( 0, (type char [edi]));	// Zero terminate.
				mov( itemCnt, ebx );
				mov( eax, tknzdStrs[ ebx*4 ] ); // Save string
				inc( itemCnt );
				breakif( (type char [edx]) = #0 );
				if( itemCnt > maxItems ) then

					HLAerror( "Too many words to tokenize in string" );
					break;

				endif;
				 
			endfor;
			popfd();
			pop( edi );
			pop( esi );

			// If the original string was empty, create at least one
			// element with an empty string to prevent troubles down
			// the line.

			if( itemCnt = 0 ) then

				str.a_cpy( "" );
				mov( eax, tknzdStrs[ 0 ] );
				inc( itemCnt );

			endif;

			// Create a dummy symbol table entry to hold
			// the type of the tokenized string array. We're not 
			// really going to enter this into the symbol table,
			// but we need it for the following constant.
			// Too bad, the memory for this is never recovered
			// (i.e., this is a memory leak). Fortunately, the
			// @tokenize function doesn't get called very often, so
			// this is no big deal.

			malloc( @size( symNode_t ));
			mov( eax, dummy );
			mov( tknzArrayStr, ecx );
			mov( ecx, symEAX.trueName );
			mov( ecx, symEAX.lcName );
			mov( &string_ste, symEAX.baseType );
			mov( Array_pt, symEAX.pType );
			mov( Type_ct, symEAX.symClass );
			mov( 4, symEAX.objectSize );
			mov( curHashTable, ecx );
			mov( hashECX.owner, ecx );
			mov( ecx, symEAX.owner );
			mov( curLexLevel, symEAX.lexLevel );
			mov( itemCnt, edx );
			lea( ecx, [edx*4] );
			mov( ecx, symEAX.objectSize );
			mov( false, symEAX.isExternal );
			mov( false, symEAX.isPublic );
			mov( false, symEAX.isReferenced );
			mov( false, symEAX.isForward );
			mov( false, symEAX.isPrivate );
			mov( false, symEAX.isReadOnly );
			mov( notp_pc, symEAX.pClass );
			mov( _none, symEAX.inReg );
			mov( NULL, symEAX.externName );
			mov( 0, symEAX.offset );
			mov( edx, symEAX.numElements );

			// Okay, create an array of attr_t objects to
			// hold the strings we've created:

			intmul( @size( attr_t ), edx, eax );
			malloc( eax );

			// Initialize the attr object to be an array of
			// string values:

			mov( attr, ecx );
			canAccess( [ecx] );
			mov( dummy, attrECX.symType );
			mov( Deferred_pt, attrECX.pType );
			mov( Constant_ct, attrECX.symClass );
			mov( eax, attrECX.arrayValues_vt );
			mov( edx, attrECX.numElements );

			// Okay, set the values for each of these attr objects
			// to the strings we allocated earlier:

			mov( eax, ecx );
			for( mov( 0, edx ); edx<itemCnt; inc( edx )) do

				defaultAttr( attrECX );
				mov( tknzdStrs[ edx*4 ], eax );
				mov( eax, attrECX.string_vt );
				mov( String_pt, attrECX.pType );
				mov( &string_ste, attrECX.symType );
				add( @size( attr_t ), ecx );

			endfor;
			clc();
			exit noerror;						

		end error;
		freeAttr( csDelims  );
		freeAttr( csQuotes  );
		freeAttr( startPosn );
		freeAttr( attr      );
		freeAttr( expr      );
		raise( ex.hlaerr );
	end noerror;

end ctTokenize;


// ctTrace-
//
//	Handles the @Trace function.

//proc( "ctTrace" )
procedure ctTrace( var attr:attr_t in ebx ); @noframe;
begin ctTrace;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( traceCode, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctTrace;


// ctTraceProcs-
//
//	Handles the @TraceProcs function.

//proc( "ctTraceProcs" )
procedure ctTraceProcs( var attr:attr_t in ebx ); @noframe;
begin ctTraceProcs;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( traceProcs, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctTraceProcs;


// ctTraceProcs-
//
//	Handles the @TraceProcs function.

//proc( "ctProcPrefix" )
procedure ctProcPrefix( var attr:attr_t in ebx ); @noframe;
begin ctProcPrefix;

	assert( attr <> NULL );
	defaultAttr( [ebx] );
	mov( Boolean_pt, attrEBX.pType );
	mov( &boolean_ste, attrEBX.symType );
	mov( Constant_ct, attrEBX.symClass );
	movzx( prefixProcs, eax );
	mov( eax, attrEBX.dword_vt );
	mov( 0, attrEBX.dword_vt[4] );
	mov( 0, attrEBX.dword_vt[8] );
	mov( 0, attrEBX.dword_vt[12] );
	clc();
	ret();

end ctProcPrefix;


// ctTrim-
//
//	Handles the @Trim function.

//proc( "ctTrim" )
procedure ctTrim( var attr:attr_t in ebx ); @noframe;
begin ctTrim;

	assert( attr <> NULL );
	//defaultAttr( attr );
	defaultAttr( attrEBX );
	begin noerror;

		begin error;

			matchLParen();
			exitif( @c ) error;
			//getString( attr );
			getString( attrEBX );
			exitif( @c ) error;
			mustMatchRParen();
			// Use the HLA stdlib str.trim function to
			// compute the result:

			str.trim( attrEBX.string_vt );
			clc();
			exit noerror;

		end error;
		//freeAttr( attr );
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;
	ret();

end ctTrim;


// ctType-
//
//	Handles the @Type function.

//proc( "ctType" )
procedure ctType( var attr:attr_t  );
begin ctType;

	assert( attr <> NULL );
	matchLParen();
	if( @c ) then

		// If error, skip to end of parameter list:

		getRightParen();
		raise( ex.hlaerr );

	else

		getIDorExpr( attr );
		if( eax = ID_tc ) then
			
			// It was an identifier. If it's a type
			// identifier, return the type name, otherwise
			// return the type associated with the ID.
			// Note that ECX points at the symbol entry for
			// the ID.	

			if( ecx = NULL ) then // undefined symbol?

				str.a_cpy( "" );

			elseif( symECX.symClass = Type_ct ) then

				// It's a class identifier, just make a copy
				// of the type's name

				str.a_cpy( symECX.trueName );

			else // must be some other kind of ID

				if( symECX.symType = NULL ) then

					// No type???

					str.a_cpy( "" );

				else

					// Get the type name:

					mov( symECX.symType, ecx );
					str.a_cpy( symECX.trueName );

				endif;

			endif;
			mov( attr, ebx );
			canAccess( [ebx] );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			mov( Constant_ct, attrEBX.symClass );
			mustMatchRParen();
			clc();

		else // must be const_tc, so we've got a constant expression.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( attrEBX.symType, ecx );
			if( ecx = NULL ) then

				// No type???

				str.a_cpy( "" );

			else

				// Get the type name:

				str.a_cpy( symECX.trueName );

			endif;
			defaultAttr( attr );
			mov( attr, ebx );
			mov( eax, attrEBX.string_vt );
			mov( String_pt, attrEBX.pType );
			mov( &string_ste, attrEBX.symType );
			mov( Constant_ct, attrEBX.symClass );
			mustMatchRParen();
			clc();

		endif;

	endif;
	
end ctType;


// ctTypeName-
//
//	Handles the @TypeName function.

//proc( "ctTypeName" )
procedure ctTypeName( var attr:attr_t in ebx ); @noframe;
begin ctTypeName;

	assert( attr <> NULL );
	//ctType( attr );
	ctType( attrEBX );
	ret();

end ctTypeName;



///////////////////////////////////////////////////////////////////////////////
//
// ctUnsFunc - Does a conversion to an unsigned integer for the ctUnsXXX 
//             functions.

//proc( "ctUnsFunc" )
procedure ctUnsFunc( var attr:attr_t );
begin ctUnsFunc;

	assert( attr <> NULL );
	begin noerror;

		begin error;

			// Initialize the return value with all zeros:

			zeroAttr( attr );

			// Parse a constant expression as the parameter for this function.

			matchLParen();
			exitif( @c ) error;
			constExpr( attr );
			mustMatchRParen();
			// Convert the constant expression's value to an integer:

			mov( attr, ebx );
			canAccess( [ebx] );
			movzx( attrEBX.pType, eax );
			switch( eax )

				// Just pass these types on through without conversion
				// They're already integers. So let the caller handle
				// range checking and stuff like that.

				case
				(
					Byte_pt,			//0
					Word_pt,			//1
					DWord_pt,			//2
					QWord_pt,			//3
					TByte_pt,			//4
					LWord_pt,			//5

					Uns8_pt,			//6
					Uns16_pt,			//7
					Uns32_pt,			//8
					Uns64_pt,			//9
					Uns128_pt,			//10

					Int8_pt,			//11
					Int16_pt,			//12
					Int32_pt,			//13
					Int64_pt,			//14
					Int128_pt,			//15

					Real32_pt,			//16
					Real64_pt,			//17

					Boolean_pt,			//20 
					Enum_pt,			//21

					Char_pt, 			//22
					XChar_pt,			//23
					Unicode_pt,			//24

					Cset_pt,
					XCset_pt
				)

					/* do nothing if one of the above cases */



				case( Real80_pt )

					// Zero out any H.O. bytes:

					mov( 0, attrEBX.word_vt[10] );
					mov( 0, attrEBX.dword_vt[12] );



				case
				(
					String_pt,
					Utf8_pt, 
					UString_pt 
				)

					// For strings, we take the first n bytes of
					// the string and use that.

					mov( attrEBX.string_vt, edx );
					canAccess( [edx] );
					str.length( edx );
					if( eax > 16 ) then

						mov( 16, eax );

					endif;
					zeroAttr( [ebx] );		// Zero out data
					push( esi );
					push( edi );
					mov( edx, esi );
					lea( edi, attrEBX.uns8_vt );
					mov( eax, ecx );
					rep.movsb();
					pop( edi );
					pop( esi );

					// Free up storage used by string value:

					strfree( edx );

				default

					HLAerror
					( 
						"Cannot convert type ", 
						pTypeStrs[ eax*4 ], 
						" to numeric form" 
						nl 
					);
					exit error;					

			endswitch;
			clc();
			exit noerror;

		end error;
		mov( attr, ebx );
		freeAttr( [ebx] );
		raise( ex.hlaerr );
	end noerror;


end ctUnsFunc;





// ctUns128-
//
//	Handles the @Uns128 function.

//proc( "ctUns128" )
procedure ctUns128( var attr:attr_t in ebx ); @noframe;
begin ctUns128;

	assert( attr <> NULL );
	//ctUnsFunc( attr );
	ctUnsFunc( attrEBX );
	mov( Uns128_pt, attrEBX.pType );
	mov( &uns128_ste, attrEBX.symType );
	ret();

end ctUns128;


// ctUns16-
//
//	Handles the @Uns16 function.

//proc( "ctUns16" )
procedure ctUns16( var attr:attr_t in ebx ); @noframe;
begin ctUns16;

	assert( attr <> NULL );
	//ctUnsFunc( attr );
	ctUnsFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.word_vt, ax );
		//zeroAttr( attr );
		zeroAttr( attrEBX );
		mov( ax, attrEBX.word_vt );
		mov( Uns16_pt, attrEBX.pType );
		mov( &uns16_ste, attrEBX.symType );

	endif;
	ret();

end ctUns16;


// ctUns32-
//
//	Handles the @Uns32 function.

//proc( "ctUns32" )
procedure ctUns32( var attr:attr_t in ebx ); @noframe;
begin ctUns32;

	assert( attr <> NULL );
	//ctUnsFunc( attr );
	ctUnsFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.dword_vt, eax );
		//zeroAttr( attr );
		zeroAttr( attrEBX );
		mov( eax, attrEBX.dword_vt );
		mov( Uns32_pt, attrEBX.pType );
		mov( &uns32_ste, attrEBX.symType );

	endif;
	ret();

end ctUns32;


// ctUns64-
//
//	Handles the @Uns64 function.

//proc( "ctUns64" )
procedure ctUns64( var attr:attr_t in ebx ); @noframe;
begin ctUns64;

	assert( attr <> NULL );
	//ctUnsFunc( attr );
	ctUnsFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.dword_vt, eax );
		mov( attrEBX.dword_vt[4], ecx );
		//zeroAttr( attr );
		zeroAttr( attrEBX );
		mov( eax, attrEBX.dword_vt );
		mov( ecx, attrEBX.dword_vt[4] );
		mov( Uns64_pt, attrEBX.pType );
		mov( &uns64_ste, attrEBX.symType );

	endif;
	ret();

end ctUns64;


// ctUns8-
//
//	Handles the @Uns8 function.

//proc( "ctUns8" )
procedure ctUns8( var attr:attr_t in ebx ); @noframe;
begin ctUns8;

	assert( attr <> NULL );
	//ctUnsFunc( attr );
	ctUnsFunc( attrEBX );
	if( @nc ) then
	
		mov( attrEBX.byte_vt, al );
		//zeroAttr( attr );
		zeroAttr( attrEBX );

		mov( al, attrEBX.byte_vt );
		mov( Uns8_pt, attrEBX.pType );
		mov( &uns8_ste, attrEBX.symType );

	endif;
	ret();

end ctUns8;


// ctUppercase-
//
//	Handles the @Uppercase function.

//proc( "ctUppercase" )
procedure ctUppercase( var attr:attr_t in ebx ); @noframe;
begin ctUppercase;

	assert( attr <> NULL );
	begin error;

		// Initialize the return value with all zeros:

		//defaultAttr( attr );
		defaultAttr( attrEBX );

		// Parse a constant expression as the parameter for this function.

		matchLParen();
		exitif( @c ) error;
		//constExpr( attr );
		constExpr( attrEBX );
		mustMatchRParen();
		movzx( attrEBX.pType, eax );
		switch( eax )

			case( Char_pt )

				// Okay, it was a character operand. Convert it to
				// upper case (if necessary).

				mov( attrEBX.char_vt, al );
				chars.toUpper( al );
				mov( al, attrEBX.char_vt );
				clc();
				ret();

			case( Unicode_pt )

				// Okay, it was a unicode operand. Convert it to
				// upper case (if necessary).

				mov( attrEBX.word_vt, ax );
				if( ax in word('a')..word('z')) then

					chars.toUpper( al );
					mov( al, attrEBX.char_vt );

				endif;
				clc();
				ret();

			case( String_pt, Utf8_pt )

				// Okay, it was a string operand. Convert it to
				// lower case (if necessary).

				str.upper( attrEBX.string_vt );
				clc();
				ret();

			case( UString_pt );

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( (type str.strRec [edx]).length, ecx );
				if( ecx <> 0 ) then

					repeat

						mov( [edx], ax );
						if( ax in word('a')..word('z')) then

							chars.toUpper( al );
							mov( al, [edx] );

						endif;
						add( 2, edx );
						sub( 2, ecx );

					until( @z );

				endif;
				clc();
				ret();



			default
				HLAerror
				( 
					"@uppercase expected a character or string argument, " nl
					"but encountered a ", 
					pTypeStrs[ eax*4 ], 
					" argument" 
					nl 
				);
				exit error;

		endswitch;
		clc();
		ret();

	end error;
	//freeAttr( attr );
	freeAttr( attrEBX );
	raise( ex.hlaerr );

end ctUppercase;


// ctUpToChar-
//
//	Handles the @UpToChar function.
//
//	@UpToChar( string, char{, remainder{, matched}} );
//
// Matches all the characters in "string" up to (but
// not including) the character argument "char".
// If the optional remainder argument is present,
// this function returns all the remaining characters
// (starting with the char) in remainder.
// If the "matched" argument is also present, this
// function returns all the characters up to (but
// not including) the matched character in "matched".
// This function returns true if it finds the character
//  somewhere in string.

//proc( "ctUpToChar" )
procedure ctUpToChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctUpToChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			
			// Get the comma separating the operands:
			
			matchComma();
			exitif( @c ) error;
			
			// Get the character argument:
			
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then
						 
				// If there was a comma, then we expect
				// a "remainder" operand:
				
				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@UpToChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				// Look for an optional comma
				// and the "matched" operand:
				
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@UpToChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @UpToChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, now
				// let's match all characters up to the specified
				// one in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while( al <> [edx+ecx] ) do

					exitif( ecx >= (type str.strRec [edx]).length ) rtnFalse;
					inc( ecx );

				endwhile;

				// Okay, we've matched to the char or to the
				// end of the string.

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				// As we've found the character, have this
				// function return true as the return result:
				
				mov( attr, ebx );
				canAccess( [ebx] );
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctUpToChar;



/////////////////////////////////////////////////////////////////
//
// ctUpToCset-
//
//	Handles the @UpToCset function.
//
// @UptoCset( string, cset{, remainder{, matched}} );
//
// Matches all the characters in "string" up to (but
// not including) the first character found in cset.
// If the optional remainder argument is present,
// this function returns all the remaining characters
// (starting with the char from cset) in remainder.
// If the "matched" argument is also present, this
// function returns all the characters up to (but
// not including) the matched character in "matched".
// This function returns true if it finds a character
// in cset somewhere in string.

//proc( "ctUpToCset" )
procedure ctUpToCset( var attr:attr_t );
var
	theCset			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctUpToCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset )":

			matchLParen();
			exitif( @c ) error;
			
			// Fetch the string:
			
			getString( attr );
			exitif( @c ) error;
			
			// separating comma:
			
			matchComma();
			exitif( @c ) error;
			
			// Fetch the character set:
			
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				// Okay, we had a comma, so the first
				// optional item must be the "remainder" ID:
				
				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@UpToCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				// Look for the optional "matched" item,
				// starting with a comma:
				
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@UpToCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			// Check for the closing parenthesis:
			
			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @UpToCset - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or fewer characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( -1, ecx );
				repeat

					inc( ecx );
					
					// Return false if we hit the end of the string:
					
					exitif( ecx >= (type str.strRec [edx]).length ) rtnFalse;
					
					// If not at end of string, check to see if the
					// current character is in the cset:
					
					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					
				until( @c );
				


				// We'll, we've a character from the set.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					// If the optional remainder argument was
					// present, then return the remainder string:
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					// If the optional "matched" argument was
					// present, return the matched string:
					
					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				// Return true to denote a match:
				
				mov( attr, ebx );
				canAccess( [ebx] );
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			mov( attr, ebx );
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctUpToCset;


// ctUpToIChar-
//
//	Handles the @UpToIChar function.
//
//	@UpToIChar( string, char{, remainder{, matched}} );
//
// Matches all the characters in "string" up to (but
// not including) the character argument "char" using
// a case insensitive comparison algorithm.
// If the optional remainder argument is present,
// this function returns all the remaining characters
// (starting with the char) in remainder.
// If the "matched" argument is also present, this
// function returns all the characters up to (but
// not including) the matched character in "matched".
// This function returns true if it finds the character
//  somewhere in string.


//proc( "ctUpToIChar" )
procedure ctUpToIChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctUpToIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@UpToIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@UpToIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @UpToIChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match one or more characters in the string:

				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				mov( 0, ecx );
				repeat

					cmp( al, [edx+ecx] );
					breakif( @e );
					mov( [edx+ecx], ah );
					if( ah in 'a'..'z' ) then

						and( $5f, ah );  // lc->UC conversion

					endif;
					cmp( al, ah );
					breakif( @e );
					inc( ecx );
					
				until( ecx >= (type str.strRec [edx]).length );
				exitif( ecx >= (type str.strRec [edx]).length ) rtnFalse;

				// We'll, we've matched up to the character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we didn't find the character. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );

	end noerror;

end ctUpToIChar;


////////////////////////////////////////////////////////////////////
//
// ctUpToIStr-
//
//	Handles the @UpToIStr function.
//
//	@UpToIStr( string, string2{, remainder{, matched}} );
//
// Matches all the characters in "string" up to (but
// not including) the string argument "string2" using
// a case insensitive comparison algorithm.
// If the optional remainder argument is present,
// this function returns all the remaining characters
// (starting with string2) in remainder.
// If the "matched" argument is also present, this
// function returns all the characters up to (but
// not including) the matched string in "matched".
// This function returns true if it finds string2
// somewhere in string.

//proc( "ctUpToIStr" )
procedure ctUpToIStr( var attr:attr_t );
var
	theStr			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctUpToIStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theStr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, string2 )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			
			// Get the comma separating the operands:
			
			matchComma();
			exitif( @c ) error;
			
			// Get the second string argument:
			
			getString( theStr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then
						 
				// If there was a comma, then we expect
				// a "remainder" operand:
				
				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@UpToIStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				// Look for an optional comma
				// and the "matched" operand:
				
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@UpToIStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @UpToIStr - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, now
				// let's see if we can find the second string
				// somewhere in the first string:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.iindex( attrEBX.string_vt, theStr.string_vt );
				exitif( eax = -1 ) rtnFalse;
				mov( eax, ecx );
				
				// Okay, we've matched to the char or to the
				// end of the string.

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				// As we've found the character, have this
				// function return true as the return result:
				
				mov( attr, ebx );
				canAccess( [ebx] );
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, the second string was not found in the first. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctUpToIStr;



//////////////////////////////////////////////////////////////////
//
// ctUpToStr-
//
//	Handles the @UpToStr function.
//
//	@UpToIStr( string, string2{, remainder{, matched}} );
//
// Matches all the characters in "string" up to (but
// not including) the string argument "string2".
// If the optional remainder argument is present,
// this function returns all the remaining characters
// (starting with string2) in remainder.
// If the "matched" argument is also present, this
// function returns all the characters up to (but
// not including) the matched string in "matched".
// This function returns true if it finds string2
// somewhere in string.

//proc( "ctUpToStr" )
procedure ctUpToStr( var attr:attr_t );
var
	theStr			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctUpToStr;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theStr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, string2 )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			
			// Get the comma separating the operands:
			
			matchComma();
			exitif( @c ) error;
			
			// Get the second string argument:
			
			getString( theStr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then
						 
				// If there was a comma, then we expect
				// a "remainder" operand:
				
				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@UpToStr argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				// Look for an optional comma
				// and the "matched" operand:
				
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@UpToStr argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @UpToStr - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, now
				// let's see if we can find the second string
				// somewhere in the first string:

				mov( attr, ebx );
				canAccess( [ebx] );
				str.index2( attrEBX.string_vt, theStr.string_vt );
				exitif( eax = -1 ) rtnFalse;
				mov( eax, ecx );
				
				// Okay, we've matched to the char or to the
				// end of the string.

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				// As we've found the character, have this
				// function return true as the return result:
				
				mov( attr, ebx );
				canAccess( [ebx] );
				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, the second string was not found in the first. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctUpToStr;


/////////////////////////////////////////////////////////////
//
// ctUtf8-
//
//	Handles the @UTF8 function.
//
// @UTF8( expr{, whichWord} );
//
//	@UTF8 is the same thing as @string except it returns the Utf8_pt type.


//proc( "ctUtf8" )
procedure ctUtf8( var attr:attr_t );
begin ctUtf8;

	ctString( attr );
	push( ebx );
	mov( attr, ebx );
	mov( Utf8_pt, attrEBX.pType );
	mov( &utf8_ste, attrEBX.symType );
	pop( ebx );

end ctUtf8;



/////////////////////////////////////////////////////////////
//
// ctWChar-
//
//	Handles the @WChar function.
//
// @WChar( expr{, whichWord} );
//
//	@WChar extracts two bytes (at byte offset "which") from
// the expression's value and uses them as the two bytes of
// the unicode character it returns.

//proc( "ctWChar" )
procedure ctWChar( var attr:attr_t ); 
var
	index		:dword;
	whichWChar	:attr_t;

begin ctWChar;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@wchar function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first dword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichWChar );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichWChar.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @wchar must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichWChar.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichWChar.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichWChar.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @wchar"
						nl
					);
					exit error;

				endif;
				mov( whichWChar.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @wchar, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as (optional) second @wchar argument must be " nl
						"less than object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an WCHAR object,
				// we only need to transfer 2 bytes, so compute
				// the minimum of objectsize-index and 2 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 2 ) then

					mov( 2, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the DWORD,
				// if the original data type (plus the index) had
				// fewer than 2 bytes:

				while( edx < 2 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the LWORD:

				xor( eax, eax );
				mov( ax,  attrEBX.word_vt[2] );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );


			else // We've got a string, UTF-8 string, or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				if( eax >= (type str.strRec [edx]).length ) then

					HLAerror
					(
						"Second argument to @wchar indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 2 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 2 ) then

					mov( 2, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the WCHAR,
				// if the original data type (plus the index) had
				// fewer than 2 bytes:

				while( esi < 2 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov(  ax, attrEBX.word_vt [ 2] );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( Unicode_pt, attrEBX.pType );
			mov( &unicode_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );

	end noerror;
	
end ctWChar;


///////////////////////////////////////////////////////////////////
//
// ctWord-
//
//	Handles the @Word function.
//
// @word( expr{, offset} );
//
// This function returns two bytes from "expr", indexed by "offset"
// as a word value.


//proc( "ctWord" )
procedure ctWord( var attr:attr_t );
var
	index		:dword;
	whichWChar	:attr_t;

begin ctWord;

	mov( attr, ebx );
	canAccess( [ebx] );
	defaultAttr( [ebx] );	// Initialize output area.
	mov( 0, index );
	begin noerror;

		begin error;

			// Eat the "(" and get the following expression:

			matchLParen();
			exitif( @c ) error;
			constExpr( [ebx] );

			// We're only going to allow primitive types for this operator.

			mov( attrEBX.pType, al );
			if( !isPrimitive( al )) then

				HLAerror
				( 
					"@word function only supports primitive data types"
					nl
				);
				exit error;

			endif;
			

			// If the second argument is not present, default to
			// returning the first dword of the expression:

			mov( 0, index );			// Default to first dword.

			// Check for optional second argument

			lex( esi );
			if( eax = ',' ) then

				// Okay, get the second argument and the closing parenthesis:

				constExpr( whichWChar );
				mustMatchRParen();
				// Verify that the index value is reasonable:

				mov( whichWChar.pType, al );
				if( !isSmallNum( al )) then

					HLAerror
					( 
						"Second argument to @Word must be a small number" 
						nl 
					);
					exit error;

				endif;
				if
				( 
						(
								al = Int8_pt 
							&&	whichWChar.int8_vt < 0
						)
					||	(
								al = Int16_pt 
							&&	whichWChar.int8_vt[1] < 0
						)
					||	(
								al = Int32_pt 
							&&	whichWChar.int8_vt[3] < 0
						)
				) then

					HLAerror
					(
						"Negative offset supplied as second argument to @Word"
						nl
					);
					exit error;

				endif;
				mov( whichWChar.uns32_vt, eax );
				mov( eax, index );

			elseif( eax <> ')' ) then

				HLAerror( "Syntax error in @wchar, expected closing ')'" nl );
				exit error;

			endif;

			// Okay, see if our index value is outside the range of the size
			// permitted by the first operand.

			mov( attr, ebx );
			canAccess( [ebx] );
			mov( index, eax );
			if
			( 
					attrEBX.pType <> String_pt
				&&	attrEBX.pType <> UString_pt 
				&&	attrEBX.pType <> Utf8_pt 
			) then

				mov( attrEBX.symType, edx );
				canAccess( [edx] );
				if( eax >= symEDX.objectSize ) then

					HLAerror
					(
						"Index supplied (",
						(type uns32 eax ),
						") as (optional) second @Word argument must be " nl
						"less than " 
						"object size (",
						symEDX.objectSize, 
						" bytes)"
						nl
					);
					exit error;

				endif;

				// We need to compute the number of bytes
				// from the index to the end of the encountered
				// type's size to determine how many bytes to
				// transfer. As we are creating an WCHAR object,
				// we only need to transfer 2 bytes, so compute
				// the minimum of objectsize-index and 2 to
				// determine how many bytes to transfer.

				mov( symEDX.objectSize, ecx );
				sub( eax, ecx );
				if( ecx >= 2 ) then

					mov( 2, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				xor( edx, edx );
				push( esi );
				mov( eax, esi );
				while( edx < ecx ) do

					mov( attrEBX.byte_vt[esi], al );
					mov( al, attrEBX.byte_vt[edx] );
					inc( edx );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the DWORD,
				// if the original data type (plus the index) had
				// fewer than 2 bytes:

				while( edx < 2 ) do

					mov( 0, attrEBX.byte_vt[edx]);
					inc( edx );

				endwhile;
				pop( esi );				

				// Zero-fill the attr object beyond the LWORD:

				xor( eax, eax );
				mov( ax,  attrEBX.word_vt[2] );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );


			else // We've got a string, UTF-8 string, or a UString

				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				if( eax >= (type str.strRec [edx]).length ) then

					HLAerror
					(
						"Second argument to @Word indexes beyond the " nl
						"end of the string supplied as 1st argument" nl
					);
					exit error;

				endif;

				// We're going to transfer a minimum of 2 bytes
				// or the number of characters left in the string.

				sub( eax, ecx );
				if( ecx >= 2 ) then

					mov( 2, ecx );

				endif;

				// Okay, transfer the bytes from the specified
				// index to the beginning of the attr object

				push( esi );
				add( eax, edx );
				xor( esi, esi );
				while( esi < ecx ) do

					mov( [edx+esi], al );
					mov( al, attrEBX.byte_vt[esi] );
					inc( esi );

				endwhile;

				// Zero-fill the remaining bytes in the WCHAR,
				// if the original data type (plus the index) had
				// fewer than 2 bytes:

				while( esi < 2 ) do

					mov( 0, attrEBX.byte_vt[esi]);
					inc( esi );

				endwhile;
				pop( esi );				

				xor( eax, eax );
				mov(  ax, attrEBX.word_vt [ 2] );
				mov( eax, attrEBX.dword_vt[ 4] );
				mov( eax, attrEBX.dword_vt[ 8] );
				mov( eax, attrEBX.dword_vt[12] );
				mov( eax, attrEBX.dword_vt[16] );
				mov( eax, attrEBX.dword_vt[20] );
				mov( eax, attrEBX.dword_vt[24] );
				mov( eax, attrEBX.dword_vt[28] );

			endif;
			mov( Word_pt, attrEBX.pType );
			mov( &word_ste, attrEBX.symType );
			clc();
			exit noerror;

		end error;

		// Drop down here if there was some sort of error.

		raise( ex.hlaerr );
	end noerror;
	
end ctWord;



////////////////////////////////////////////////////////////////////////
//
// ctWSorEOS-
//
//	Handles the @WSorEOS function.
//
//	@WSorEOS( string{, remainder{, matched}} );
//
// Matches all the whitespace characters or an end of string
// at the beginning of the "string" argument.
// If the optional remainder argument is present,
// this function returns all the remaining characters
// in remainder (empty string if matching EOS).
// If the "matched" argument is also present, this
// function returns all the characters up to the first
// non-whitespace character in "matched".
// This function false if the string begins with a
// non-whitespace character and is not the empty string.

//proc( "ctWSorEOS" )
procedure ctWSorEOS( var attr:attr_t );
var
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctWSorEOS;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@WSorEOS argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as third "
							"@WSorEOS argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @WSorEOS - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match whitespace characters or the EOS:

				mov( -1, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				repeat
				
					inc( ecx );
					movzx( (type char [edx+ecx]), eax );
					bt( eax, WhiteSpace );
				
				until( @nc );
				exitif( ecx = 0 && al <> #0 ) rtnFalse;
				

				// We'll, we've matched at least 1 WS character
				// or the end of string. Set up the Matched and 
				// Remainder strings, free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;

			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctWSorEOS;


/////////////////////////////////////////////////////////////
//
// ctWSthenEOS-
//
//	Handles the @WSthenEOS function.
//
//	@WSthenEOS( string{, matched} );
//
// Matches zero or more whitespace characters followed by the
// end of the string at the beginning of the "string" argument.
// If the "matched" argument is present, this function returns 
// all matched whitespace characters in the "matched" argument.
//
// This function returns true if it finds zero or more WS chars
// followed by the end of string, it returns false otherwise.

//proc( "ctWSthenEOS" )
procedure ctWSthenEOS( var attr:attr_t );
var
	matchedSym		:symNodePtr_t;
	hasMatched		:boolean;

begin ctWSthenEOS;

	assert( attr <> NULL );
	defaultAttr( attr );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as second "
						"@WSthenEOS argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, matchedSym );
				mov( true, hasMatched );
				
				// Need to scan for ")" symbol...
				
				lex( esi );

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @WSthenEOS - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match whitespace characters or the EOS:

				mov( -1, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				repeat
				
					inc( ecx );
					movzx( (type char [edx+ecx]), eax );
					bt( eax, WhiteSpace );
				
				until( @nc );
				
				// Return false if we're not at the end of the string:
				
				exitif( al <> #0 ) rtnFalse;
				

				// We'll, we've matched at least 1 WS character
				// or the end of string. Set up the Matched string, 
				// free the string data, and return. 

				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we failed to match WS followed by EOS. Free the
			// string and return false. Also, set the matched string 
			// to the empty string.
			
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctWSthenEOS;



/////////////////////////////////////////////////////////////////
//
// ctZeroOrMoreChar-
//
//	Handles the @ZeroOrMoreChar function.
//
// @ZeroOrMoreChar( string, char{, remainder{, matched}} )
//
// Matches zero or more instances of "char" found at the
// beginning of "string". As zero is valid, this function
// always returns true if the parameter list is valid. 
// If the remainder argument is present, this code returns 
// all characters starting with the 

//proc( "ctZeroOrMoreChar" )
procedure ctZeroOrMoreChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrMoreChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrMoreChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrMoreChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrMoreChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or more characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				while
				( 
						al = [edx+ecx] 
					&&	ecx < (type str.strRec [edx]).length
				) do
				
					inc( ecx );

				endwhile;


				// We'll, we've matched at least 1 character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrMoreChar;



//////////////////////////////////////////////////////////////////
//
// ctZeroOrMoreCset-
//
//	Handles the @ZeroOrMoreCset function.

//proc( "ctZeroOrMoreCset" )
procedure ctZeroOrMoreCset( var attr:attr_t );
var
	theCset			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrMoreCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrMoreCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrMoreCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrMoreCset - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or more characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( -1, ecx );
				repeat

					inc( ecx );
					movzx( (type char [edx+ecx]), eax );
					bt( eax, theCset.cset_vt );
					
				until( @nc || ecx >= (type str.strRec [edx]).length);


				// We'll, we've matched at least one character.
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we matched more than n characters. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrMoreCset;



/////////////////////////////////////////////////////////////////
//
// ctZeroOrMoreIChar-
//
//	Handles the @ZeroOrMoreIChar function.

//proc( "ctZeroOrMoreIChar" )
procedure ctZeroOrMoreIChar( var attr:attr_t ); 
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrMoreIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrMoreIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrMoreIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrMoreIChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or more characters in the string:

				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( 0, ecx );
				repeat

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						breakif( @ne );

					endif;
					inc( ecx );
					
				until( ecx >= (type str.strRec [edx]).length );

				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we had an error. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrMoreIChar;



/////////////////////////////////////////////////////////////////////
//
// ctZeroOrMoreWS-
//
//	Handles the @ZeroOrMoreWS function.

//proc( "ctZeroOrMoreWS" )
procedure ctZeroOrMoreWS( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrMoreWS;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char, n )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as the second "
						"@ZeroOrMoreWS argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as the third "
							"@ZeroOrMoreWS argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrMoreWS - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match 'n' or more characters in the string:

				mov( 0, ecx );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				while
				( 
						(type char [edx+ecx]) <= ' '
					&&	(type char [edx+ecx]) <> #0
					&&	ecx < (type str.strRec [edx]).length
				) do
				
					inc( ecx );

				endwhile;
				
				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we had an error. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrMoreWS;


////////////////////////////////////////////////////////////////////
//
// ctZeroOrOneChar-
//
//	Handles the @ZeroOrOneChar function.

//proc( "ctZeroOrOneChar" )
procedure ctZeroOrOneChar( var attr:attr_t );
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrOneChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrOneChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrOneChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrOneChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or one characters in the string:

				mov( 0, ecx );
				mov( theChar.char_vt, al );
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				if
				( 
						al = [edx+ecx] 
					&&	ecx < (type str.strRec [edx]).length
				) then
				
					inc( ecx );

				endif;

				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we had an error. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrOneChar;



///////////////////////////////////////////////////////////////////////
//
// ctZeroOrOneCset-
//
//	Handles the @ZeroOrOneCset function.

//proc( "ctZeroOrOneCset" )
procedure ctZeroOrOneCset( var attr:attr_t ); 
var
	theCset			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrOneCset;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theCset );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, cset )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getCset( theCset );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrOneCset argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrOneCset argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrOneCset - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or one characters in the string:

				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( 0, ecx );
				movzx( (type char [edx]), eax );
				bt( eax, theCset.cset_vt );
				if( @c ) then
				
					inc( ecx );
					
				endif;

				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we have an error. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrOneCset;



/////////////////////////////////////////////////////////////////
//
// ctZeroOrOneIChar-
//
//	Handles the @ZeroOrOneIChar function.

//proc( "ctZeroOrOneIChar" )
procedure ctZeroOrOneIChar( var attr:attr_t ); 
var
	theChar			:attr_t;
	remainderSym	:symNodePtr_t;
	matchedSym		:symNodePtr_t;
	hasRemainder	:boolean;
	hasMatched		:boolean;

begin ctZeroOrOneIChar;

	assert( attr <> NULL );
	defaultAttr( attr );
	defaultAttr( theChar );
	mov( false, hasRemainder );
	mov( false, hasMatched );
	begin noerror;

		begin error;

			// Get the values from the source file 
			// "(string, char )":

			matchLParen();
			exitif( @c ) error;
			getString( attr );
			exitif( @c ) error;
			matchComma();
			exitif( @c ) error;
			getChar( theChar );
			exitif( @c ) error;

			// Handle the optional items here:

			lex( esi );
			if( eax = ',' ) then

				lex( esi );
				if( ebx <> ID_tc ) then

					HLAerror
					( 
						"Expected an identifier as third "
						"@ZeroOrOneIChar argument" 
						nl 
					);
					exit error;

				endif;
				checkValID( [ecx] );
				exitif( @c ) error;
				mov( tokenECX.symNode, eax );
				mov( eax, remainderSym );
				mov( true, hasRemainder );
	
				lex( esi );
				if( eax = ',' ) then

					lex( esi );
					if( ebx <> ID_tc ) then

						HLAerror
						( 
							"Expected an identifier as fourth "
							"@ZeroOrOneIChar argument" 
							nl 
						);
						exit error;

					endif;
					checkValID( [ecx] );
					exitif( @c ) error;
					mov( tokenECX.symNode, eax );
					mov( eax, matchedSym );
					mov( true, hasMatched );

					// Need to scan for the next token
					// because the following code expects
					// the token to be sitting in EAX:

					lex( esi );

				endif;

			endif;

			if( eax <> ')' ) then

				HLAerror
				( 
					"Syntax error in @ZeroOrOneIChar - expected a ')'" nl 
				);
				freeTkn( [ecx] );
				exit error;

			endif;

			begin rtnFalse;

				// Okay, all the parameters seem reasonable, let's see if we
				// can match zero or more characters in the string:

				mov( theChar.char_vt, al );
				if( al in 'a'..'z' ) then
					
					and( $5f, al );

				endif;
				mov( attr, ebx );
				canAccess( [ebx] );
				mov( attrEBX.string_vt, edx );
				canAccess( [edx] );
				mov( 0, ecx );
				begin testZeroOrOne;

					cmp( al, [edx+ecx] );
					if( @ne ) then

						mov( [edx+ecx], ah );
						if( ah in 'a'..'z' ) then

							and( $5f, ah );  // lc->UC conversion

						endif;
						cmp( al, ah );
						exitif( @ne ) testZeroOrOne;

					endif;
					inc( ecx );
					
				end testZeroOrOne;

				// Set up the Matched and Remainder strings,
				// free the string data, and return. 

				if( hasRemainder ) then
				
					mov( remainderSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.length( attrEBX.string_vt );
					sub( ecx, eax );
					str.a_substr( attrEBX.string_vt, ecx, eax );
					mov( eax, symEDX.va.string_vt );

				endif;
				if( hasMatched ) then

					mov( matchedSym, edx );
					canAccess( [edx] );
					mov( &string_ste, symEDX.symType );
					mov( String_pt, symEDX.pType );
					mov( 4, symEDX.objectSize );
					str.a_substr( attrEBX.string_vt, 0, ecx );
					mov( eax, symEDX.va.string_vt );

				endif;

				freeAttr( [ebx] );
				defaultAttr( [ebx] );
				mov( Boolean_pt, attrEBX.pType );
				mov( &boolean_ste, attrEBX.symType );
				mov( true, attrEBX.boolean_vt );
				clc();
				exit noerror;
				
			end rtnFalse; 
			 
			// Okay, we had an error. Free the
			// string and return false. Also, set the remainder equal
			// to the whole string and set the matched string to the
			// empty string.
			
			if( hasRemainder ) then
			
				mov( remainderSym, ecx );
				canAccess( [ecx] );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );
				str.a_cpy( attrEBX.string_vt );
				mov( eax, symECX.va.string_vt );

			endif;
			if( hasMatched ) then

				mov( matchedSym, ecx );
				canAccess( [ecx] );
				str.a_cpy( "" );
				mov( eax, symECX.va.string_vt );
				mov( &string_ste, symECX.symType );
				mov( String_pt, symECX.pType );
				mov( 4, symECX.objectSize );

			endif;
			defaultAttr( [ebx] );
			mov( Boolean_pt, attrEBX.pType );
			mov( &boolean_ste, attrEBX.symType );
			mov( false, attrEBX.boolean_vt );
			clc();
			exit noerror;
			
		end error;
		freeAttr( attrEBX );
		raise( ex.hlaerr );
	end noerror;

end ctZeroOrOneIChar;




////////////////////////////////////////////////////////////////////////
//
// handleCompileTimeFuncs-
//
//	Dispatches control to an appropriate function based on the value
// passed in the "whichFunc" parameter (which must be a token value
// for one of the HLA "@xxxxx" reserved words).

//proc( "handleCompileTimeFuncs" )
procedure handleCompileTimeFuncs( whichFunc:dword; var attr:attr_t );
begin handleCompileTimeFuncs;

	assert( attr <> NULL );
	push( eax );
	push( ebx );
	push( ecx );
	push( edx );

	// Switch off the function value passed in EAX.
	// Could have used a simple jump table here, but this switch
	// statement is easier to maintain as it doesn't depend on the
	// token values appearing in any particular order.

	mov( whichFunc, eax );
	switch( eax );

		case( tkn_at_abs )
			ctAbs( attr );

		case( tkn_at_alignstack )
			ctAlignStack( attr );

		case( tkn_at_arity )
			ctArity( attr );

		case( tkn_at_bound )
			ctBound( attr );

		case( tkn_at_byte )
			ctByte( attr );

		case( tkn_at_ceil )
			ctCeil( attr );

		case( tkn_at_char )
			ctChar( attr );

		case( tkn_at_class )
			ctClass( attr );

		case( tkn_at_cos )
			ctCos( attr );

		case( tkn_at_cset )
			ctCset( attr );

		case( tkn_at_curlex )
			ctCurlex( attr );

		case( tkn_at_curobject )
			ctCurobj( attr );

		case( tkn_at_curoffset )
			ctCuroffset( attr );

		case( tkn_at_date )
			ctDate( attr );

		case( tkn_at_defined )
			ctDefined( attr );

		case( tkn_at_delete )
			ctDelete( attr );

		case( tkn_at_dim )
			ctDim( attr );

		case( tkn_at_display )
			ctDisplay( attr );

		case( tkn_at_dword )
			ctDword( attr );

		case( tkn_at_elements )
			ctElements( attr );

		case( tkn_at_elementsize )
			ctElementSize( attr );

		case( tkn_at_enter )
			ctEnter( attr );

		case( tkn_at_enumsize )
			ctEnumSize( attr );

		case( tkn_at_eos )
			ctEOS( attr );

		// @eval is directly handled by the lexer.
		//
		//case( tkn_at_eval )
		//	ctEval( attr );

		case( tkn_at_exactlynchar )
			ctExactlyNChar( attr );

		case( tkn_at_exactlyncset )
			ctExactlyNCset( attr );

		case( tkn_at_exactlynichar )
			ctExactlyNIChar( attr );

		case( tkn_at_exactlyntomchar )
			ctExactlyNToMChar( attr );

		case( tkn_at_exactlyntomcset )
			ctExactlyNToMCset( attr );

		case( tkn_at_exactlyntomichar )
			ctExactlyNToMIChar( attr );

		case( tkn_at_exp )
			ctExp( attr );

		case( tkn_at_extract )
			ctExtract( attr );

		case( tkn_at_filename )
			ctFilename( attr );

		case( tkn_at_firstnchar )
			ctFirstNChar( attr );

		case( tkn_at_firstncset )
			ctFirstNCset( attr );

		case( tkn_at_firstnichar )
			ctFirstNIChar( attr );

		case( tkn_at_floor )
			ctFloor( attr );

		case( tkn_at_frame )
			ctFrame( attr );

		case( tkn_at_index )
			ctIndex( attr );

		case( tkn_at_insert )
			ctInsert( attr );

		case( tkn_at_int128 )
			ctInt128( attr );

		case( tkn_at_int16 )
			ctInt16( attr );

		case( tkn_at_int32 )
			ctInt32( attr );

		case( tkn_at_int64 )
			ctInt64( attr );

		case( tkn_at_int8 )
			ctInt8( attr );

		case( tkn_at_into )
			ctInto( attr );

		case( tkn_at_isalpha )
			ctIsAlpha( attr );

		case( tkn_at_isalphanum )
			ctIsAlphaNum( attr );

		case( tkn_at_isclass )
			ctIsClass( attr );

		case( tkn_at_isconst )
			ctIsConst( attr );

		case( tkn_at_isdigit )
			ctIsDigit( attr );

		case( tkn_at_isexpr )
			ctIsExpr( attr );

		case( tkn_at_isexternal )
			ctIsExternal( attr );

		case( tkn_at_islower )
			ctIsLower( attr );

		case( tkn_at_ismem )
			ctIsMem( attr );

		case( tkn_at_isreg )
			ctIsReg( attr );

		case( tkn_at_isreg16 )
			ctIsReg16( attr );

		case( tkn_at_isreg32 )
			ctIsReg32( attr );

		case( tkn_at_isreg8 )
			isReg8( attr );

		case( tkn_at_isregfpu )
			ctIsRegFPU( attr );

		case( tkn_at_isregmmx )
			ctIsRegMMX( attr );

		case( tkn_at_isregsse )
			ctIsRegSSE( attr );

		case( tkn_at_isspace )
			ctIsSpace( attr );

		case( tkn_at_istype )
			ctIsType( attr );

		case( tkn_at_isupper )
			ctIsUpper( attr );

		case( tkn_at_isxdigit )
			ctIsXDigit( attr );

		//case( tkn_at_lastobject )
		//	ctLastObject( attr );

		case( tkn_at_leave )
			ctLeave( attr );

		case( tkn_at_length )
			ctLength( attr );

		case( tkn_at_lex )
			ctLex( attr );

		case( tkn_at_linenumber )
			ctLineNumber( attr );

		case( tkn_at_localoffset )
			ctLocalOffset( attr );

		case( tkn_at_localsyms )
			ctLocalSyms( attr );

		case( tkn_at_log )
			ctLog( attr );

		case( tkn_at_log10 )
			ctLog10( attr );

		case( tkn_at_lowercase )
			ctLowercase( attr );

		case( tkn_at_lword )
			ctLword( attr );

		case( tkn_at_matchid )
			ctMatchID( attr );

		case( tkn_at_matchintconst )
			ctMatchIntConst( attr );

		case( tkn_at_matchistr )
			ctMatchIStr( attr );

		case( tkn_at_matchnumconst )
			ctMatchNumConst( attr );

		case( tkn_at_matchrealconst )
			ctMatchRealConst( attr );

		case( tkn_at_matchstr )
			ctMatchStr( attr );

		case( tkn_at_matchstrconst )
			ctMatchStrConst( attr );

		case( tkn_at_matchtoistr )
			ctMatchToIStr( attr );

		case( tkn_at_matchtostr )
			ctMatchToStr( attr );

		case( tkn_at_max )
			ctMax( attr );

		case( tkn_at_min )
			ctMin( attr );

		case( tkn_at_name )
			ctName( attr );

		case( tkn_at_noalignstack )
			ctNoAlignStack( attr );

		case( tkn_at_nodisplay )
			ctNoDisplay( attr );

		case( tkn_at_noenter )
			ctNoEnter( attr );

		case( tkn_at_noframe )
			ctNoFrame( attr );

		case( tkn_at_noleave )
			ctNoLeave( attr );

		case( tkn_at_norlesschar )
			ctNorLessChar( attr );

		case( tkn_at_norlesscset )
			ctNorLessCset( attr );

		case( tkn_at_norlessichar )
			ctNorLessIChar( attr );

		case( tkn_at_normorechar )
			ctNorMoreChar( attr );

		case( tkn_at_normorecset )
			ctNorMoreCset( attr );

		case( tkn_at_normoreichar )
			ctNorMoreIChar( attr );

		case( tkn_at_nostackalign )
			ctNoStackAlign( attr );

		case( tkn_at_ntomchar )
			ctNtoMChar( attr );

		case( tkn_at_ntomcset )
			ctNtoMCset( attr );

		case( tkn_at_ntomichar )
			ctNtoMIChar( attr );

		case( tkn_at_odd )
			ctOdd( attr );

		case( tkn_at_offset )
			ctOffset( attr );

		case( tkn_at_onechar )
			ctOneChar( attr );

		case( tkn_at_onecset )
			ctOneCset( attr );

		case( tkn_at_oneichar )
			ctOneIChar( attr );

		case( tkn_at_oneormorechar )
			ctOneOrMoreChar( attr );

		case( tkn_at_oneormorecset )
			ctOneOrMoreCset( attr );

		case( tkn_at_oneormoreichar )
			ctOneOrMoreIChar( attr );

		case( tkn_at_oneormorews )
			ctOneOrMoreWS( attr );

		case( tkn_at_parmoffset )
			ctParmOffset( attr );

		case( tkn_at_parms )
			ctParms( attr );

		case( tkn_at_pclass )
			ctPClass( attr );

		case( tkn_at_peekchar )
			ctPeekChar( attr );

		case( tkn_at_peekcset )
			ctPeekCset( attr );

		case( tkn_at_peekichar )
			ctPeekIChar( attr );

		case( tkn_at_peekws )
			ctPeekWS( attr );

		case( tkn_at_pointer )
			ctPointer( attr );

		case( tkn_at_procprefix )
			ctProcPrefix( attr );

		case( tkn_at_ptype )
			ctPtype( attr );

		case( tkn_at_qword )
			ctQword( attr );

		case( tkn_at_random )
			ctRandom( attr );

		case( tkn_at_randomize )
			ctRandomize( attr );

		case( tkn_at_read )
			ctRead( attr );

		case( tkn_at_real32 )
			ctReal32( attr );

		case( tkn_at_real64 )
			ctReal64( attr );

		case( tkn_at_real80 )
			ctReal80( attr );

		case( tkn_at_rindex )
			ctRIndex( attr );

		case( tkn_at_section )
			ctSection( attr );

		case( tkn_at_sin )
			ctSin( attr );

		case( tkn_at_size )
			ctSize( attr );

		case( tkn_at_sqrt )
			ctSqrt( attr );

		case( tkn_at_stackalign )
			ctStackAlign( attr );

		case( tkn_at_staticname )
			ctStaticName( attr );

		case( tkn_at_strbrk )
			ctStrBrk( attr );

		case( tkn_at_string )
			ctString( attr );

		case( tkn_at_strset )
			ctStrSet( attr );

		case( tkn_at_strspan )
			ctStrSpan( attr );

		case( tkn_at_substr )
			ctSubstr( attr );

		case( tkn_at_tan )
			ctTan( attr );

		case( tkn_at_time )
			ctTime( attr );

		case( tkn_at_tokenize )
			ctTokenize( attr );

		case( tkn_at_trace )
			ctTrace( attr );

		case( tkn_at_traceprocs )
			ctTraceProcs( attr );

		case( tkn_at_trim )
			ctTrim( attr );

		case( tkn_at_type )
			ctType( attr );

		case( tkn_at_typename )
			ctTypeName( attr );

		case( tkn_at_uns128 )
			ctUns128( attr );

		case( tkn_at_uns16 )
			ctUns16( attr );

		case( tkn_at_uns32 )
			ctUns32( attr );

		case( tkn_at_uns64 )
			ctUns64( attr );

		case( tkn_at_uns8 )
			ctUns8( attr );

		case( tkn_at_uppercase )
			ctUppercase( attr );

		case( tkn_at_uptochar )
			ctUpToChar( attr );

		case( tkn_at_uptocset )
			ctUpToCset( attr );

		case( tkn_at_uptoichar )
			ctUpToIChar( attr );

		case( tkn_at_uptoistr )
			ctUpToIStr( attr );

		case( tkn_at_uptostr )
			ctUpToStr( attr );

		case( tkn_at_utf8 )
			ctUtf8( attr );

		case( tkn_at_wchar )
			ctWChar( attr );

		case( tkn_at_word )
			ctWord( attr );

		case( tkn_at_wsoreos )
			ctWSorEOS( attr );

		case( tkn_at_wstheneos )
			ctWSthenEOS( attr );

		case( tkn_at_zeroormorechar )
			ctZeroOrMoreChar( attr );

		case( tkn_at_zeroormorecset )
			ctZeroOrMoreCset( attr );

		case( tkn_at_zeroormoreichar )
			ctZeroOrMoreIChar( attr );

		case( tkn_at_zeroormorews )
			ctZeroOrMoreWS( attr );

		case( tkn_at_zerooronechar )
			ctZeroOrOneChar( attr );

		case( tkn_at_zerooronecset )
			ctZeroOrOneCset( attr );

		case( tkn_at_zerooroneichar )
			ctZeroOrOneIChar( attr );

		// Some of the "@xxxx" reserved words do not correspond to
		// compile-time functions. If one of these appears in an
		// expression, report a syntax error.

		default
			HLAerror
			(
				"Syntax error: unexpected special HLA "
				"reserved word in expression"
				nl
			);
			raise( ex.hlaerr );

	endswitch;

	// Catch any uncaught errors and raise an exception here.

	raiseErr( @c );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );

end handleCompileTimeFuncs;



end ctlFuncs;
